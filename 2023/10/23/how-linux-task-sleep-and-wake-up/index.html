<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>리눅스 태스크가 대기하고 깨어나는 방법 | dfkdream's blog</title>
<meta name=keywords content="Linux,kernel"><meta name=description content="태스크는 파일 처리 등 IO 작업을 요청한 다음 대기 상태에 들어가고, 처리가 완료되면 깨어나 남은 작업을 수행한다. 너무나 당연한 과정이라 인식하고 있지도 않았지만,"><meta name=author content="dfkdream"><link rel=canonical href=https://blog.dfkdream.dev/2023/10/23/how-linux-task-sleep-and-wake-up/><meta name=google-site-verification content="XwrsDxNNW1dGpEQAJ4cr5u3icxvUZJONnbKoYaOjtLI"><meta name=msvalidate.01 content="687D269162DCBD0F34F985BBBBD71683"><meta name=naver-site-verification content="f7672890d940101a2350722c42da5b75da998e2f"><link crossorigin=anonymous href=/assets/css/stylesheet.cd21efb3c18f3ca2a86167d2b45e8a2b34a8f14a80bd01a2f21e0f69d4513dc6.css integrity="sha256-zSHvs8GPPKKoYWfStF6KKzSo8UqAvQGi8h4PadRRPcY=" rel="preload stylesheet" as=style><link rel=icon href=https://icons.dfkdream.dev/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://blog.dfkdream.dev/2023/10/23/how-linux-task-sleep-and-wake-up/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=/js/turbo.es2017-esm.22b55635ee2fa87f977c1deb6c1458603792eaf7d26a933be1e3172c2af7f78b.js integrity="sha256-IrVWNe4vqH+XfB3rbBRYYDeS6vfSapM74eMXLCr394s=" type=module></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GMSSDPMXZE"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GMSSDPMXZE")}</script><meta property="og:title" content="리눅스 태스크가 대기하고 깨어나는 방법"><meta property="og:description" content="태스크는 파일 처리 등 IO 작업을 요청한 다음 대기 상태에 들어가고, 처리가 완료되면 깨어나 남은 작업을 수행한다. 너무나 당연한 과정이라 인식하고 있지도 않았지만,"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.dfkdream.dev/2023/10/23/how-linux-task-sleep-and-wake-up/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-23T20:39:15+09:00"><meta property="article:modified_time" content="2023-10-23T20:39:15+09:00"><meta property="og:site_name" content="dfkdream's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="리눅스 태스크가 대기하고 깨어나는 방법"><meta name=twitter:description content="태스크는 파일 처리 등 IO 작업을 요청한 다음 대기 상태에 들어가고, 처리가 완료되면 깨어나 남은 작업을 수행한다. 너무나 당연한 과정이라 인식하고 있지도 않았지만,"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.dfkdream.dev/posts/"},{"@type":"ListItem","position":2,"name":"리눅스 태스크가 대기하고 깨어나는 방법","item":"https://blog.dfkdream.dev/2023/10/23/how-linux-task-sleep-and-wake-up/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"리눅스 태스크가 대기하고 깨어나는 방법","name":"리눅스 태스크가 대기하고 깨어나는 방법","description":"태스크는 파일 처리 등 IO 작업을 요청한 다음 대기 상태에 들어가고, 처리가 완료되면 깨어나 남은 작업을 수행한다. 너무나 당연한 과정이라 인식하고 있지도 않았지만,","keywords":["Linux","kernel"],"articleBody":"태스크는 파일 처리 등 IO 작업을 요청한 다음 대기 상태에 들어가고, 처리가 완료되면 깨어나 남은 작업을 수행한다. 너무나 당연한 과정이라 인식하고 있지도 않았지만, 리눅스 커널은 이 작업을 여러 가지 단계들로 나누어 수행하고 있다.\n대기 대기 상태는 시그널 처리가 가능한 TASK_INTERRUPTIBLE와 시그널 처리가 불가능한TASK_UNINTERRUPTIBLE 두 가지 상태로 나누어진다. 이 상태에 들어간 태스크는 대기열에 자신의 구조체를 두고, 인터럽트가 발생하기를 기다리게 된다.\n깨우기 인터럽트가 발생하면 커널은 대기열에 들어가 있는 모든 태스크를 깨운다. 깨어난 태스크는 발생한 이벤트와 자신이 깨어날 조건을 비교해 작업을 계속 수행할지, 아니면 대기열에 다시 들어갈지를 결정한다. 커널이 조건을 직접 확인해 스레드를 깨우는 것이 더 효율적으로 보이지만 이런 방식이 채택된 이유는 깨어날 조건이 매우 복잡할 수도 있기 때문이다.\ninotify_read 대기 및 깨우기 과정을 잘 보여주는 inotify_read 함수를 분석해 보자.\n출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/fs/notify/inotify/inotify_user.c\nstatic ssize_t inotify_read(struct file *file, char __user *buf, size_t count, loff_t *pos) { struct fsnotify_group *group; struct fsnotify_event *kevent; char __user *start; int ret; DEFINE_WAIT_FUNC(wait, woken_wake_function); start = buf; group = file-\u003eprivate_data; add_wait_queue(\u0026group-\u003enotification_waitq, \u0026wait); while (1) { spin_lock(\u0026group-\u003enotification_lock); kevent = get_one_event(group, count); spin_unlock(\u0026group-\u003enotification_lock); pr_debug(\"%s: group=%p kevent=%p\\n\", __func__, group, kevent); if (kevent) { ret = PTR_ERR(kevent); if (IS_ERR(kevent)) break; ret = copy_event_to_user(group, kevent, buf); fsnotify_destroy_event(group, kevent); if (ret \u003c 0) break; buf += ret; count -= ret; continue; } ret = -EAGAIN; if (file-\u003ef_flags \u0026 O_NONBLOCK) break; ret = -ERESTARTSYS; if (signal_pending(current)) break; if (start != buf) break; wait_woken(\u0026wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); } remove_wait_queue(\u0026group-\u003enotification_waitq, \u0026wait); if (start != buf \u0026\u0026 ret != -EFAULT) ret = buf - start; return ret; } DEFINE_WAIT_FUNC 출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/include/linux/wait.h\n#define DEFINE_WAIT_FUNC(name, function)\t\\ struct wait_queue_entry name = {\t\\ .private\t= current,\t\\ .func\t= function,\t\\ .entry\t= LIST_HEAD_INIT((name).entry),\t\\ } DEFINE_WAIT_FUNC 매크로는 대기열 (wait_queue) 안에 들어갈 wait_queue_entry 구조체를 선언하고 있다. 이 매크로는 private, func, entry 세 개의 필드를 초기화한다. private 필드에는 현재 태스크의 task_struct가, func 필드에는 깨어난 직후 실행할 함수가 (이 경우에는 woken_wake_func), entry에는 이중 연결 리스트 구조체가 들어간다.\nwoken_wake_func 출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/wait.c\nint woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key) { /* Pairs with the smp_store_mb() in wait_woken(). */ smp_mb(); /* C */ wq_entry-\u003eflags |= WQ_FLAG_WOKEN; return default_wake_function(wq_entry, mode, sync, key); } woken_wake_function은 wait_queue_entry의 WQ_FLAG_WOKEN플래그 비트를 1로 변경하고 default_wake_function을 호출한다. 이 플래그는 태스크가 방금 막 깨어났다는 것을 의미한다.\n출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/core.c\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags, void *key) { WARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) \u0026\u0026 wake_flags \u0026 ~(WF_SYNC|WF_CURRENT_CPU)); return try_to_wake_up(curr-\u003eprivate, mode, wake_flags); } default_wake_function은 try_to_wake_up을 실행시키고, 이 함수는 ttwu 함수들을 호출해 태스크를 이전에 실행되던 프로세서의 runqueue에 다시 삽입한다.\nadd_wait_queue 이렇게 만들어진 wait_queue_entry를 파일 기술자의 대기 큐에 삽입한 다음, 태스크는 while(1) 루프에 진입한다. 이 루프 안에서 태스크는 wait_woken을 호출해 이벤트가 발생할 때까지 대기 상태에 들어간다.\n이벤트 발생 이벤트가 발생되면 가장 먼저 woken_wake_function이 실행되고, 깨어난 태스크는 get_one_event 함수를 통해 이벤트를 가져오려고 시도한다. 이벤트를 가져오는 데 성공한 경우, 가져온 이벤트를 사용자 메모리에 복사하고 remove_wait_queue를 사용해 대기열에서 자신의 wait_queue_entry를 삭제해 대기를 종료한다. 만약 이벤트를 가져오지 못했다면 wait_woken 함수를 실행해 다시 대기 상태에 들어간다.\nwait_woken 출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/wait.c\nlong wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout) { /* * The below executes an smp_mb(), which matches with the full barrier * executed by the try_to_wake_up() in woken_wake_function() such that * either we see the store to wq_entry-\u003eflags in woken_wake_function() * or woken_wake_function() sees our store to current-\u003estate. */ set_current_state(mode); /* A */ if (!(wq_entry-\u003eflags \u0026 WQ_FLAG_WOKEN) \u0026\u0026 !kthread_should_stop_or_park()) timeout = schedule_timeout(timeout); __set_current_state(TASK_RUNNING); /* * The below executes an smp_mb(), which matches with the smp_mb() (C) * in woken_wake_function() such that either we see the wait condition * being true or the store to wq_entry-\u003eflags in woken_wake_function() * follows ours in the coherence order. */ smp_store_mb(wq_entry-\u003eflags, wq_entry-\u003eflags \u0026 ~WQ_FLAG_WOKEN); /* B */ return timeout; } wait_woken 함수는 가장 먼저 set_current_state 함수가 실행하고, 현재 태스크의 상태를 TASK_INTERRUPTIBLE 또는 TASK_UNINTERRUPTIBLE 상태로 바꾼다. 실제 대기는 schedule_timeout 호출 시 시작된다는 점에 주의하자.\n!(wq_entry-\u003eflags \u0026 WQ_FLAG_WOKEN) 표현식은 태스크가 wait_woken 함수를 호출하기 전에 이벤트가 발생해 woken_wake_func이 실행되었을 때 참이 된다. 이 경우 태스크는 대기하지 않고 바로 이벤트를 처리해야 한다. 그렇지 않다면, schedule_timeout을 호출해 다른 태스크에게 프로세서를 양보하고 timeout만큼 대기한다.\n이벤트에 의해 깨어났을 경우, __set_current_state 함수를 호출해 태스크의 상태를 TASK_RUNNING으로 변경한다. 함수명 앞의 __는 이 함수를 smp_mb로 보호받고 있는 안전한 환경에서만 실행해야 한다는 것을 의미한다.\n그 후, smp_store_mb함수를 호출해 wait_queue_entry의 WQ_FLAG_WOKEN비트를 0으로 변경한다. 이렇게 태스크를 깨우는 프로세스가 끝나고, 실행된 태스크는 while(1) 루프 안에서 실행 조건을 검사해 처리를 계속할지, 아니면 다시 대기할지를 결정하게 된다.\n정리 실행 과정을 다시 정리해 보면 다음과 같다.\ninotify_read -\u003e add_wait_queue -\u003e wait_woken -\u003e woken_wake_func -\u003e ttwu -\u003e wait_woken -\u003e 실행 조건 검사 -\u003e wait_woken / remove_wait_queue 이 과정에서 WQ_FLAG_WOKEN 비트의 변화는 다음과 같다.\ncall inotify_read add_wait_queue wait_woken woken_wake_func wait_woken inotify_read remove_wait_queue WQ_FLAG_WOKEN 0 0 0 1 0 0 0 실습 #include #include #include #define EVENT_SIZE (sizeof(struct inotify_event)) #define BUF_LEN (1024 * (EVENT_SIZE + 16)) int main(void){ int fd = inotify_init(); int wd = inotify_add_watch(fd, \".\", IN_MODIFY|IN_CREATE|IN_DELETE); int pid = fork(); printf(\"pid %d created\\n\", pid); char buffer[BUF_LEN]; printf(\"pid %d before_read\\n\", pid); int len = read(fd, buffer, BUF_LEN); printf(\"pid %d after_read\\n\", pid); for (int i=0; i\u003clen;){ struct inotify_event *event = (struct inotify_event *) \u0026buffer[i]; if (event-\u003elen){ if (event-\u003emask \u0026 IN_CREATE) { printf(\"The file %s was created.\\n\", event-\u003ename); } else if (event-\u003emask \u0026 IN_DELETE) { printf(\"The file %s was deleted.\\n\", event-\u003ename); } else if (event-\u003emask \u0026 IN_MODIFY) { printf(\"The file %s was modified.\\n\", event-\u003ename); } } i += EVENT_SIZE + event-\u003elen; } } 동일한 대기 큐를 두 개의 태스크가 공유하도록 하기 위해 inotify_init으로 파일 기술자를 가져온 후 fork를 수행하여 동일한 파일 기술자에 두 번의 read를 수행하게 하였다.\npid 1028216 created pid 1028216 before_read pid 0 created pid 0 before_read pid 0 after_read The file test was created. pid 1028216 after_read The file test was deleted. 테스트 결과 첫 번째 inotify 이벤트에서는 대기 큐의 가장 처음에 위치한 (=가장 마지막에 들어간) 자식 태스크가 실행되었으며 두 번째 이벤트에서는 부모 태스크가 실행된 것을 확인할 수 있었다.\n참고문헌 https://stackoverflow.com/questions/13351172/inotify-file-in-c ","wordCount":"2131","inLanguage":"ko","datePublished":"2023-10-23T20:39:15+09:00","dateModified":"2023-10-23T20:39:15+09:00","author":{"@type":"Person","name":"dfkdream"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.dfkdream.dev/2023/10/23/how-linux-task-sleep-and-wake-up/"},"publisher":{"@type":"Organization","name":"dfkdream's blog","logo":{"@type":"ImageObject","url":"https://blog.dfkdream.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.dfkdream.dev/ accesskey=h title="dfkdream's blog (Alt + H)">dfkdream's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://garden.dfkdream.dev title=garden><span>garden</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://blog.dfkdream.dev/archives/ title=archive><span>archive</span></a></li><li><a href=https://blog.dfkdream.dev/categories/ title=categories><span>categories</span></a></li><li><a href=https://blog.dfkdream.dev/tags/ title=tags><span>tags</span></a></li><li><a href=https://blog.dfkdream.dev/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.dfkdream.dev/>홈</a>&nbsp;»&nbsp;<a href=https://blog.dfkdream.dev/posts/>Posts</a></div><h1 class=post-title>리눅스 태스크가 대기하고 깨어나는 방법</h1><div class=post-meta><span title='2023-10-23 20:39:15 +0900 +0900'>2023년 10월 23일 </span>&nbsp;·&nbsp;5 분&nbsp;·&nbsp;2131 단어&nbsp;·&nbsp;dfkdream</div></header><div class=post-content><p>태스크는 파일 처리 등 IO 작업을 요청한 다음 대기 상태에 들어가고, 처리가 완료되면 깨어나 남은 작업을 수행한다. 너무나 당연한 과정이라 인식하고 있지도 않았지만, 리눅스 커널은 이 작업을 여러 가지 단계들로 나누어 수행하고 있다.</p><h1 id=대기>대기<a hidden class=anchor aria-hidden=true href=#대기>#</a></h1><p>대기 상태는 시그널 처리가 가능한 <code>TASK_INTERRUPTIBLE</code>와 시그널 처리가 불가능한<code>TASK_UNINTERRUPTIBLE</code> 두 가지 상태로 나누어진다. 이 상태에 들어간 태스크는 대기열에 자신의 구조체를 두고, 인터럽트가 발생하기를 기다리게 된다.</p><h1 id=깨우기>깨우기<a hidden class=anchor aria-hidden=true href=#깨우기>#</a></h1><p>인터럽트가 발생하면 커널은 대기열에 들어가 있는 모든 태스크를 깨운다. 깨어난 태스크는 발생한 이벤트와 자신이 깨어날 조건을 비교해 작업을 계속 수행할지, 아니면 대기열에 다시 들어갈지를 결정한다. 커널이 조건을 직접 확인해 스레드를 깨우는 것이 더 효율적으로 보이지만 이런 방식이 채택된 이유는 깨어날 조건이 매우 복잡할 수도 있기 때문이다.</p><h1 id=inotify_read>inotify_read<a hidden class=anchor aria-hidden=true href=#inotify_read>#</a></h1><p>대기 및 깨우기 과정을 잘 보여주는 inotify_read 함수를 분석해 보자.</p><p>출처: <a href=https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/fs/notify/inotify/inotify_user.c>https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/fs/notify/inotify/inotify_user.c</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>ssize_t</span> <span class=nf>inotify_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			    <span class=kt>size_t</span> <span class=n>count</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=n>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>fsnotify_group</span> <span class=o>*</span><span class=n>group</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>fsnotify_event</span> <span class=o>*</span><span class=n>kevent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>DEFINE_WAIT_FUNC</span><span class=p>(</span><span class=n>wait</span><span class=p>,</span> <span class=n>woken_wake_function</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>start</span> <span class=o>=</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>group</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>private_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>add_wait_queue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>group</span><span class=o>-&gt;</span><span class=n>notification_waitq</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>wait</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>spin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>group</span><span class=o>-&gt;</span><span class=n>notification_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>kevent</span> <span class=o>=</span> <span class=nf>get_one_event</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>spin_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>group</span><span class=o>-&gt;</span><span class=n>notification_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nf>pr_debug</span><span class=p>(</span><span class=s>&#34;%s: group=%p kevent=%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>,</span> <span class=n>group</span><span class=p>,</span> <span class=n>kevent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>kevent</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>ret</span> <span class=o>=</span> <span class=nf>PTR_ERR</span><span class=p>(</span><span class=n>kevent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=nf>IS_ERR</span><span class=p>(</span><span class=n>kevent</span><span class=p>))</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>ret</span> <span class=o>=</span> <span class=nf>copy_event_to_user</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=n>kevent</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=nf>fsnotify_destroy_event</span><span class=p>(</span><span class=n>group</span><span class=p>,</span> <span class=n>kevent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>buf</span> <span class=o>+=</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>count</span> <span class=o>-=</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_flags</span> <span class=o>&amp;</span> <span class=n>O_NONBLOCK</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>ERESTARTSYS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=nf>signal_pending</span><span class=p>(</span><span class=n>current</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>start</span> <span class=o>!=</span> <span class=n>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nf>wait_woken</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wait</span><span class=p>,</span> <span class=n>TASK_INTERRUPTIBLE</span><span class=p>,</span> <span class=n>MAX_SCHEDULE_TIMEOUT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>remove_wait_queue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>group</span><span class=o>-&gt;</span><span class=n>notification_waitq</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>wait</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>start</span> <span class=o>!=</span> <span class=n>buf</span> <span class=o>&amp;&amp;</span> <span class=n>ret</span> <span class=o>!=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>ret</span> <span class=o>=</span> <span class=n>buf</span> <span class=o>-</span> <span class=n>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=define_wait_func>DEFINE_WAIT_FUNC<a hidden class=anchor aria-hidden=true href=#define_wait_func>#</a></h2><p>출처: <a href=https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/include/linux/wait.h>https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/include/linux/wait.h</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define DEFINE_WAIT_FUNC(name, function)					\
</span></span></span><span class=line><span class=cl><span class=cp>	struct wait_queue_entry name = {					\
</span></span></span><span class=line><span class=cl><span class=cp>		.private	= current,					\
</span></span></span><span class=line><span class=cl><span class=cp>		.func		= function,					\
</span></span></span><span class=line><span class=cl><span class=cp>		.entry		= LIST_HEAD_INIT((name).entry),			\
</span></span></span><span class=line><span class=cl><span class=cp>	}
</span></span></span></code></pre></div><p><code>DEFINE_WAIT_FUNC</code> 매크로는 대기열 (wait_queue) 안에 들어갈 <code>wait_queue_entry</code> 구조체를 선언하고 있다. 이 매크로는 <code>private</code>, <code>func</code>, <code>entry</code> 세 개의 필드를 초기화한다. <code>private</code> 필드에는 현재 태스크의 <code>task_struct</code>가, <code>func</code> 필드에는 깨어난 직후 실행할 함수가 (이 경우에는 <code>woken_wake_func</code>), <code>entry</code>에는 <a href=/2023/10/18/linked-list-of-linux-kernel/>이중 연결 리스트 구조체</a>가 들어간다.</p><h2 id=woken_wake_func>woken_wake_func<a hidden class=anchor aria-hidden=true href=#woken_wake_func>#</a></h2><p>출처: <a href=https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/wait.c>https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/wait.c</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>woken_wake_function</span><span class=p>(</span><span class=k>struct</span> <span class=n>wait_queue_entry</span> <span class=o>*</span><span class=n>wq_entry</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>mode</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sync</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* Pairs with the smp_store_mb() in wait_woken(). */</span>
</span></span><span class=line><span class=cl>	<span class=nf>smp_mb</span><span class=p>();</span> <span class=cm>/* C */</span>
</span></span><span class=line><span class=cl>	<span class=n>wq_entry</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>|=</span> <span class=n>WQ_FLAG_WOKEN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>default_wake_function</span><span class=p>(</span><span class=n>wq_entry</span><span class=p>,</span> <span class=n>mode</span><span class=p>,</span> <span class=n>sync</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>woken_wake_function</code>은 <code>wait_queue_entry</code>의 <code>WQ_FLAG_WOKEN</code>플래그 비트를 1로 변경하고 <code>default_wake_function</code>을 호출한다. 이 플래그는 태스크가 방금 막 깨어났다는 것을 의미한다.</p><p>출처: <a href=https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/core.c>https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/core.c</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>default_wake_function</span><span class=p>(</span><span class=kt>wait_queue_entry_t</span> <span class=o>*</span><span class=n>curr</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>mode</span><span class=p>,</span> <span class=kt>int</span> <span class=n>wake_flags</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>WARN_ON_ONCE</span><span class=p>(</span><span class=nf>IS_ENABLED</span><span class=p>(</span><span class=n>CONFIG_SCHED_DEBUG</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>wake_flags</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=n>WF_SYNC</span><span class=o>|</span><span class=n>WF_CURRENT_CPU</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>try_to_wake_up</span><span class=p>(</span><span class=n>curr</span><span class=o>-&gt;</span><span class=n>private</span><span class=p>,</span> <span class=n>mode</span><span class=p>,</span> <span class=n>wake_flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>default_wake_function</code>은 <code>try_to_wake_up</code>을 실행시키고, 이 함수는 <code>ttwu</code> 함수들을 호출해 태스크를 이전에 실행되던 프로세서의 runqueue에 다시 삽입한다.</p><h2 id=add_wait_queue>add_wait_queue<a hidden class=anchor aria-hidden=true href=#add_wait_queue>#</a></h2><p>이렇게 만들어진 <code>wait_queue_entry</code>를 파일 기술자의 대기 큐에 삽입한 다음, 태스크는 <code>while(1)</code> 루프에 진입한다. 이 루프 안에서 태스크는 <code>wait_woken</code>을 호출해 이벤트가 발생할 때까지 대기 상태에 들어간다.</p><h2 id=이벤트-발생>이벤트 발생<a hidden class=anchor aria-hidden=true href=#이벤트-발생>#</a></h2><p>이벤트가 발생되면 가장 먼저 <code>woken_wake_function</code>이 실행되고, 깨어난 태스크는 <code>get_one_event</code> 함수를 통해 이벤트를 가져오려고 시도한다. 이벤트를 가져오는 데 성공한 경우, 가져온 이벤트를 사용자 메모리에 복사하고 <code>remove_wait_queue</code>를 사용해 대기열에서 자신의 <code>wait_queue_entry</code>를 삭제해 대기를 종료한다. 만약 이벤트를 가져오지 못했다면 <code>wait_woken</code> 함수를 실행해 다시 대기 상태에 들어간다.</p><h2 id=wait_woken>wait_woken<a hidden class=anchor aria-hidden=true href=#wait_woken>#</a></h2><p>출처: <a href=https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/wait.c>https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/wait.c</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>long</span> <span class=nf>wait_woken</span><span class=p>(</span><span class=k>struct</span> <span class=n>wait_queue_entry</span> <span class=o>*</span><span class=n>wq_entry</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>mode</span><span class=p>,</span> <span class=kt>long</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	 * The below executes an smp_mb(), which matches with the full barrier
</span></span></span><span class=line><span class=cl><span class=cm>	 * executed by the try_to_wake_up() in woken_wake_function() such that
</span></span></span><span class=line><span class=cl><span class=cm>	 * either we see the store to wq_entry-&gt;flags in woken_wake_function()
</span></span></span><span class=line><span class=cl><span class=cm>	 * or woken_wake_function() sees our store to current-&gt;state.
</span></span></span><span class=line><span class=cl><span class=cm>	 */</span>
</span></span><span class=line><span class=cl>	<span class=nf>set_current_state</span><span class=p>(</span><span class=n>mode</span><span class=p>);</span> <span class=cm>/* A */</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>wq_entry</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>WQ_FLAG_WOKEN</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=nf>kthread_should_stop_or_park</span><span class=p>())</span>
</span></span><span class=line><span class=cl>		<span class=n>timeout</span> <span class=o>=</span> <span class=nf>schedule_timeout</span><span class=p>(</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>__set_current_state</span><span class=p>(</span><span class=n>TASK_RUNNING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	 * The below executes an smp_mb(), which matches with the smp_mb() (C)
</span></span></span><span class=line><span class=cl><span class=cm>	 * in woken_wake_function() such that either we see the wait condition
</span></span></span><span class=line><span class=cl><span class=cm>	 * being true or the store to wq_entry-&gt;flags in woken_wake_function()
</span></span></span><span class=line><span class=cl><span class=cm>	 * follows ours in the coherence order.
</span></span></span><span class=line><span class=cl><span class=cm>	 */</span>
</span></span><span class=line><span class=cl>	<span class=nf>smp_store_mb</span><span class=p>(</span><span class=n>wq_entry</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>,</span> <span class=n>wq_entry</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>WQ_FLAG_WOKEN</span><span class=p>);</span> <span class=cm>/* B */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>timeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>wait_woken</code> 함수는 가장 먼저 <code>set_current_state</code> 함수가 실행하고, 현재 태스크의 상태를 <code>TASK_INTERRUPTIBLE</code> 또는 <code>TASK_UNINTERRUPTIBLE</code> 상태로 바꾼다. 실제 대기는 <code>schedule_timeout</code> 호출 시 시작된다는 점에 주의하자.</p><p><code>!(wq_entry->flags & WQ_FLAG_WOKEN)</code> 표현식은 태스크가 <code>wait_woken</code> 함수를 호출하기 전에 이벤트가 발생해 <code>woken_wake_func</code>이 실행되었을 때 참이 된다. 이 경우 태스크는 대기하지 않고 바로 이벤트를 처리해야 한다. 그렇지 않다면, <code>schedule_timeout</code>을 호출해 다른 태스크에게 프로세서를 양보하고 <code>timeout</code>만큼 대기한다.</p><p>이벤트에 의해 깨어났을 경우, <code>__set_current_state</code> 함수를 호출해 태스크의 상태를 <code>TASK_RUNNING</code>으로 변경한다. 함수명 앞의 <code>__</code>는 이 함수를 <code>smp_mb</code>로 보호받고 있는 안전한 환경에서만 실행해야 한다는 것을 의미한다.</p><p>그 후, <code>smp_store_mb</code>함수를 호출해 <code>wait_queue_entry</code>의 <code>WQ_FLAG_WOKEN</code>비트를 0으로 변경한다. 이렇게 태스크를 깨우는 프로세스가 끝나고, 실행된 태스크는 <code>while(1)</code> 루프 안에서 실행 조건을 검사해 처리를 계속할지, 아니면 다시 대기할지를 결정하게 된다.</p><h1 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h1><p>실행 과정을 다시 정리해 보면 다음과 같다.</p><pre tabindex=0><code>inotify_read -&gt; add_wait_queue -&gt; wait_woken -&gt; woken_wake_func -&gt; ttwu -&gt; wait_woken -&gt; 실행 조건 검사 -&gt; wait_woken / remove_wait_queue
</code></pre><p>이 과정에서 <code>WQ_FLAG_WOKEN</code> 비트의 변화는 다음과 같다.</p><table><thead><tr><th>call</th><th>inotify_read</th><th>add_wait_queue</th><th>wait_woken</th><th>woken_wake_func</th><th>wait_woken</th><th>inotify_read</th><th>remove_wait_queue</th></tr></thead><tbody><tr><td>WQ_FLAG_WOKEN</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h1 id=실습>실습<a hidden class=anchor aria-hidden=true href=#실습>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;  </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/inotify.h&gt;  </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;  </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  
</span></span><span class=line><span class=cl><span class=cp>#define EVENT_SIZE  (sizeof(struct inotify_event))  
</span></span></span><span class=line><span class=cl><span class=cp>#define BUF_LEN     (1024 * (EVENT_SIZE + 16))  
</span></span></span><span class=line><span class=cl><span class=cp></span>  
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>){</span>  
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>inotify_init</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>wd</span> <span class=o>=</span> <span class=nf>inotify_add_watch</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=s>&#34;.&#34;</span><span class=p>,</span> <span class=n>IN_MODIFY</span><span class=o>|</span><span class=n>IN_CREATE</span><span class=o>|</span><span class=n>IN_DELETE</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid %d created</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=n>BUF_LEN</span><span class=p>];</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid %d before_read</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>BUF_LEN</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid %d after_read</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>len</span><span class=p>;){</span>  
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>inotify_event</span> <span class=o>*</span><span class=n>event</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>inotify_event</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>buffer</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>  
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>event</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>){</span>  
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>event</span><span class=o>-&gt;</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=n>IN_CREATE</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;The file %s was created.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>event</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>event</span><span class=o>-&gt;</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=n>IN_DELETE</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;The file %s was deleted.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>event</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>event</span><span class=o>-&gt;</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=n>IN_MODIFY</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;The file %s was modified.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>event</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>            <span class=p>}</span>  
</span></span><span class=line><span class=cl>        <span class=p>}</span>  
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>+=</span> <span class=n>EVENT_SIZE</span> <span class=o>+</span> <span class=n>event</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>동일한 대기 큐를 두 개의 태스크가 공유하도록 하기 위해 <code>inotify_init</code>으로 파일 기술자를 가져온 후 <code>fork</code>를 수행하여 동일한 파일 기술자에 두 번의 <code>read</code>를 수행하게 하였다.</p><pre tabindex=0><code>pid 1028216 created
pid 1028216 before_read
pid 0 created
pid 0 before_read
pid 0 after_read
The file test was created.
pid 1028216 after_read
The file test was deleted.
</code></pre><p>테스트 결과 첫 번째 inotify 이벤트에서는 대기 큐의 가장 처음에 위치한 (=가장 마지막에 들어간) 자식 태스크가 실행되었으며 두 번째 이벤트에서는 부모 태스크가 실행된 것을 확인할 수 있었다.</p><h1 id=참고문헌>참고문헌<a hidden class=anchor aria-hidden=true href=#참고문헌>#</a></h1><ul><li><a href=https://stackoverflow.com/questions/13351172/inotify-file-in-c>https://stackoverflow.com/questions/13351172/inotify-file-in-c</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.dfkdream.dev/tags/linux/>Linux</a></li><li><a href=https://blog.dfkdream.dev/tags/kernel/>Kernel</a></li></ul><nav class=paginav><a class=next href=https://blog.dfkdream.dev/2023/10/18/linked-list-of-linux-kernel/><span class=title>다음 페이지 »</span><br><span>리눅스 커널의 연결 리스트</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 리눅스 태스크가 대기하고 깨어나는 방법 on x" href="https://x.com/intent/tweet/?text=%eb%a6%ac%eb%88%85%ec%8a%a4%20%ed%83%9c%ec%8a%a4%ed%81%ac%ea%b0%80%20%eb%8c%80%ea%b8%b0%ed%95%98%ea%b3%a0%20%ea%b9%a8%ec%96%b4%eb%82%98%eb%8a%94%20%eb%b0%a9%eb%b2%95&amp;url=https%3a%2f%2fblog.dfkdream.dev%2f2023%2f10%2f23%2fhow-linux-task-sleep-and-wake-up%2f&amp;hashtags=Linux%2ckernel"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 리눅스 태스크가 대기하고 깨어나는 방법 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.dfkdream.dev%2f2023%2f10%2f23%2fhow-linux-task-sleep-and-wake-up%2f&amp;title=%eb%a6%ac%eb%88%85%ec%8a%a4%20%ed%83%9c%ec%8a%a4%ed%81%ac%ea%b0%80%20%eb%8c%80%ea%b8%b0%ed%95%98%ea%b3%a0%20%ea%b9%a8%ec%96%b4%eb%82%98%eb%8a%94%20%eb%b0%a9%eb%b2%95&amp;summary=%eb%a6%ac%eb%88%85%ec%8a%a4%20%ed%83%9c%ec%8a%a4%ed%81%ac%ea%b0%80%20%eb%8c%80%ea%b8%b0%ed%95%98%ea%b3%a0%20%ea%b9%a8%ec%96%b4%eb%82%98%eb%8a%94%20%eb%b0%a9%eb%b2%95&amp;source=https%3a%2f%2fblog.dfkdream.dev%2f2023%2f10%2f23%2fhow-linux-task-sleep-and-wake-up%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 리눅스 태스크가 대기하고 깨어나는 방법 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.dfkdream.dev%2f2023%2f10%2f23%2fhow-linux-task-sleep-and-wake-up%2f&title=%eb%a6%ac%eb%88%85%ec%8a%a4%20%ed%83%9c%ec%8a%a4%ed%81%ac%ea%b0%80%20%eb%8c%80%ea%b8%b0%ed%95%98%ea%b3%a0%20%ea%b9%a8%ec%96%b4%eb%82%98%eb%8a%94%20%eb%b0%a9%eb%b2%95"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 리눅스 태스크가 대기하고 깨어나는 방법 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.dfkdream.dev%2f2023%2f10%2f23%2fhow-linux-task-sleep-and-wake-up%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 리눅스 태스크가 대기하고 깨어나는 방법 on whatsapp" href="https://api.whatsapp.com/send?text=%eb%a6%ac%eb%88%85%ec%8a%a4%20%ed%83%9c%ec%8a%a4%ed%81%ac%ea%b0%80%20%eb%8c%80%ea%b8%b0%ed%95%98%ea%b3%a0%20%ea%b9%a8%ec%96%b4%eb%82%98%eb%8a%94%20%eb%b0%a9%eb%b2%95%20-%20https%3a%2f%2fblog.dfkdream.dev%2f2023%2f10%2f23%2fhow-linux-task-sleep-and-wake-up%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 리눅스 태스크가 대기하고 깨어나는 방법 on telegram" href="https://telegram.me/share/url?text=%eb%a6%ac%eb%88%85%ec%8a%a4%20%ed%83%9c%ec%8a%a4%ed%81%ac%ea%b0%80%20%eb%8c%80%ea%b8%b0%ed%95%98%ea%b3%a0%20%ea%b9%a8%ec%96%b4%eb%82%98%eb%8a%94%20%eb%b0%a9%eb%b2%95&amp;url=https%3a%2f%2fblog.dfkdream.dev%2f2023%2f10%2f23%2fhow-linux-task-sleep-and-wake-up%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 리눅스 태스크가 대기하고 깨어나는 방법 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%eb%a6%ac%eb%88%85%ec%8a%a4%20%ed%83%9c%ec%8a%a4%ed%81%ac%ea%b0%80%20%eb%8c%80%ea%b8%b0%ed%95%98%ea%b3%a0%20%ea%b9%a8%ec%96%b4%eb%82%98%eb%8a%94%20%eb%b0%a9%eb%b2%95&u=https%3a%2f%2fblog.dfkdream.dev%2f2023%2f10%2f23%2fhow-linux-task-sleep-and-wake-up%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=dfkdream/blog issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.dfkdream.dev/>dfkdream's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>var menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>