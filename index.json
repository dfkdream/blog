[{"content":"Github 등 Git 서버에서는 커미터가 자신임을 증명하기 위해 GPG 서명을 사용할 수 있습니다. 이때 사용되는 GPG 키는 보안을 위해 유효기간을 지정하는 것이 권장되는데, 유효기간이 지나면 해당 키로 커밋을 할 수 없는 등 문제가 발생합니다.\n이런 문제가 발생했을 때 GPG 키를 갱신하는 방법입니다.\n테스트 환경 macOS Monterey gpg (GnuPG) 2.3.4 저장된 키 목록 확인 gpg --list-keys \u0026lt;keybox 파일 경로\u0026gt; ---------------------------------- pub rsa4096 \u0026lt;생성일\u0026gt; [SC] [expires: \u0026lt;만료일\u0026gt;] \u0026lt;Key ID\u0026gt; uid [ultimate] \u0026lt;username\u0026gt; \u0026lt;\u0026lt;email\u0026gt; sub rsa4096 \u0026lt;생성일\u0026gt; [E] [expires: \u0026lt;만료일\u0026gt;] Key ID는 유효기간 연장을 위해 필요하니 잘 확인하시기 바랍니다.\n키 유효기간 연장 gpg --edit-key \u0026lt;Key ID\u0026gt; 아무것도 입력하지 않으면 Primary key를 수정하게 됩니다.\ngpg\u0026gt; expire Changing expiration time for the primary key. Please specify how long the key should be valid. 0 = key does not expire \u0026lt;n\u0026gt; = key expires in n days \u0026lt;n\u0026gt;w = key expires in n weeks \u0026lt;n\u0026gt;m = key expires in n months \u0026lt;n\u0026gt;y = key expires in n years Key is valid for? (0) n+단위를 입력해 만료일을 오늘 날짜로부터 n만큼 연장시킵니다.\nSubkey의 유효기간도 연장시켜 줍시다.\ngpg\u0026gt; key 1 gpg\u0026gt; expire 이후의 명령은 Primary key와 동일합니다.\n마지막으로 수정 내용을 저장합니다.\ngpg\u0026gt; save 공개키 내보내기 gpg --armor --export \u0026lt;Key ID\u0026gt; 지정된 키를 텍스트 형식으로 내보냅니다. 표준 출력으로 키 내용이 출력되니 리디렉션을 사용해 클립보드에 바로 복사할 수도 있습니다.\n이제 Git 서버 관리 페이지에서 기존 공개키를 삭제하고 내보낸 키를 다시 등록하면 됩니다.\n","permalink":"https://blog.dfkdream.dev/2022/03/30/renewing-expired-gpg-key/","summary":"Github 등 Git 서버에서는 커미터가 자신임을 증명하기 위해 GPG 서명을 사용할 수 있습니다. 이때 사용되는 GPG 키는 보안을 위해 유효기간을 지정하는 것이 권장되는데, 유효기간","title":"만료된 GPG 키 갱신하기 (유효기간 연장)"},{"content":"pyenv, pyenv-virtualenv 설치 방법과 자주 사용되는 명령어들을 모아 보았습니다.\n테스트 환경 macOS Monterey iTerm2 ZSH pyenv 설치 brew install pyenv echo \u0026#39;eval \u0026#34;$(pyenv init --path)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zprofile echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 특정 버전의 python 설치 pyenv install \u0026lt;python-version\u0026gt; ex)\npyenv install 3.8.12 pyenv-virtualenv 설치 brew install pyenv-virtualenv echo \u0026#39;eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc virtualenv 생성 pyenv virtualenv \u0026lt;python-version\u0026gt; \u0026lt;venv-name\u0026gt; ex)\npyenv virtualenv 3.8.12 venv virtualenv 적용 pyenv activate \u0026lt;venv-name\u0026gt; ex)\npyenv activate venv 특정 폴더에 virtualenv 자동 적용 pyenv local \u0026lt;venv-name\u0026gt; ex)\npyenv local venv 실행 시 현재 디렉토리에 .python-version 파일이 생성되고 pyenv가 이 파일을 자동으로 인식해 가상 환경을 적용해 줍니다.\nvirtualenv 삭제 pyenv uninstall \u0026lt;venv-name\u0026gt; ex)\npyenv uninstall venv ","permalink":"https://blog.dfkdream.dev/2022/03/08/installing-and-using-pyenv-macos/","summary":"pyenv, pyenv-virtualenv 설치 방법과 자주 사용되는 명령어들을 모아 보았습니다. 테스트 환경 macOS Monterey iTerm2 ZSH pyenv 설치 brew install pyenv echo \u0026#39;eval \u0026#34;$(pyenv init --path)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zprofile echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 특정 버전의 python 설치 pyenv install \u0026lt;python-version\u0026gt; ex) pyenv install 3.8.12","title":"macOS에 pyenv 설치, 사용하기"},{"content":"zsh-autosuggestions와 zsh-syntax-highlighting은 zsh 사용을 엄청 편리하게 해 주는 플러그인입니다. 그런데 macOS에서 이 플러그인들을 설치했더니 플러그인 간에 충돌이 발생해 자동완성된 명령어가 보이지 않거나 하이라이팅이 제대로 되지 않는 문제가 발생했습니다. 이 포스트에서는 이런 문제들을 해결해 보겠습니다.\n테스트 환경 macOS Big Sur iTerm2 Build 3.3.7 oh-my-zsh 플러그인 설치 먼저 더 많은 명령어 자동 완성 목록을 사용하기 위해 zsh-completions를 설치해 줍시다.\n% git clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions 다음으로 zsh-syntax-highlighting과 zsh-autosuggestions를 설치해 주겠습니다.\n% git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting % git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 설치가 모두 끝나면 ~/.zshrc 파일을 다음과 같이 수정해 플러그인을 활성화해 주겠습니다.\nplugins=( [Plugins...] zsh-syntax-highlighting zsh-completions zsh-autosuggestions ) ... autoload -U compinit \u0026amp;\u0026amp; compinit 가장 마지막 줄의 autoload...는 zsh-completions 활성화를 위한 부분입니다. 파일 가장 마지막 줄에 추가해 줍시다.\n설치가 모두 끝났습니다! 마지막으로 다음 명령어를 입력해 설정 파일을 로드해 주겠습니다.\nsource ~/.zshrc 이러면 이제 자동완성과 문법 하이라이팅이 이쁘게 되어야 하는디\u0026hellip;\nTroubles 이대로 설정하면 데모에서 본 것처럼 표시가 되지 않습니다. 제 경우에는\n자동완성된 부분이 입력한 부분과 구분이 되지 않음 자동완성된 부분 글자가 하나만 보이고 나머지는 보이지 않음 이런 문제가 발생했습니다.\nTroubleshooting 자동완성된 부분이 입력한 부분과 구분이 되지 않음 먼저 1번 문제부터 고쳐 보겠습니다. 이 문제는 zsh-syntax-highlighting이 macOS Big Sur에 기본으로 설치된 zsh 5.8 (x86_64-apple-darwin20.0)을 인식하지 못해 발생하는 문제입니다. brew를 사용해 zsh를 업데이트(설치)해 줍시다.\n% brew install zsh 이제 터미널을 새로 열면 zsh가 업데이트된 것을 확인할 수 있습니다.\n% zsh --version zsh 5.8 (x86_64-apple-darwin20.1.0) (실행 시점과 OS버전 / 아키텍쳐에 따라 다를 수 있습니다.)\n이 문제는 이제 해결!\n자동완성된 부분 글자가 하나만 보이고 나머지는 보이지 않음 그런데.. 기본 테마가 아닌 Solarized Dark 등의 컬러 스킴을 사용하시는 경우 자동완성된 부분 글자가 제대로 보이지 않는 문제가 발생합니다. 이건 zsh-autosuggestions가 기본 자동완성 하이라이팅 색상으로 사용하는 ANSI Bright Black 색상이 Background 색상과 동일하게 설정되어 있어 생기는 문제입니다.\niTerm2 설정 (cmd+,) \u0026gt; Profiles \u0026gt; Colors \u0026gt; ANSI Colors \u0026gt; Black \u0026gt; Bright 색상을 다른 색으로 변경해 줍시다. 저의 경우 #2a5965로 설정했습니다.\n이러면 이제 진짜로 설정 끝!\n참고문헌 / 출처 본격 macOS에 개발 환경 구축하기 - Subicura\u0026rsquo;s Blog autosuggestion not working for oh-my-zsh #416 - zsh-users/zsh-autosuggestion Conflict with zsh-autosuggestions under zsh 5.8 (and only that version) #756 - zsh-users/zsh-syntax-highlighting ","permalink":"https://blog.dfkdream.dev/2020/02/21/zsh-autosuggest-with-highlight/","summary":"zsh-autosuggestions와 zsh-syntax-highlighting은 zsh 사용을 엄청 편리하게 해 주는 플러그인입니다. 그런데 ma","title":"zsh-autosuggest와 zsh-syntax-highlighting 충돌 문제 해결"},{"content":"리플렉션 (reflect 패키지) 를 사용하면 구조체를 배열처럼 인덱스로 접근할 수 있습니다.\nimport( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strconv\u0026#34; ) type test struct{ A int B int C string } 값 읽기 t := test{1,2,\u0026#34;3\u0026#34;} fmt.Println(reflect.ValueOf(t).Field(0).Int()) fmt.Println(reflect.ValueOf(t).Field(1).Int()) fmt.Println(reflect.ValueOf(t).Field(2).String()) 결과 1 2 3 자료형이 일치하지 않을 경우 패닉이 발생합니다.\nt := test{1,2,\u0026#34;3\u0026#34;} fmt.Println(reflect.ValueOf(t).Field(0).Int()) fmt.Println(reflect.ValueOf(t).Field(1).Int()) fmt.Println(reflect.ValueOf(t).Field(2).Int()) 결과 1 2 panic: reflect: call of reflect.Value.Int on string Value 그러므로 값을 읽기 전에는 Kind() 함수를 이용해 타입 검사를 해 주어야 합니다.\nt := test{1,2,\u0026#34;3\u0026#34;} for i:=0;i\u0026lt;3;i++{ if reflect.ValueOf(t).Field(i).Kind()==reflect.String{ fmt.Println(reflect.ValueOf(t).Field(i).String()) }else{ fmt.Println(reflect.ValueOf(t).Field(i).Int()) } } 결과 1 2 3 값 쓰기 var t test reflect.ValueOf(\u0026amp;t).Elem().Field(0).SetInt(int64(1)) reflect.ValueOf(\u0026amp;t).Elem().Field(1).SetInt(int64(2)) reflect.ValueOf(\u0026amp;t).Elem().Field(2).SetString(\u0026#34;3\u0026#34;) fmt.Println(t) 결과 {1 2 3} 값을 읽는 코드와 비슷합니다. 다만 구조체 필드의 값을 변경하기 위해 ValueOf 함수의 파라미터로 포인터를 넘겼고 역참조를 위해 Elem() 함수를 사용하고 있습니다.\n값 쓰기의 경우에도 읽기와 마찬가지로 자료형이 일치하지 않을 경우 패닉이 발생합니다.\nvar t test reflect.ValueOf(\u0026amp;t).Elem().Field(0).SetInt(int64(1)) reflect.ValueOf(\u0026amp;t).Elem().Field(1).SetInt(int64(2)) reflect.ValueOf(\u0026amp;t).Elem().Field(2).SetInt(int64(3)) fmt.Println(t) 결과 panic: reflect: call of reflect.Value.SetInt on string Value 그러므로 Kind() 함수를 이용해 타입 검사를 해 주어야 합니다.\nvar t test a:=[]int{1,2,3} for i,n:=range a{ if reflect.ValueOf(t).Field(i).Kind()==reflect.String{ reflect.ValueOf(\u0026amp;t).Elem().Field(i).SetString(strconv.Itoa(n)) }else{ reflect.ValueOf(\u0026amp;t).Elem().Field(i).SetInt(int64(n)) } } fmt.Println(t) 결과 {1 2 3} 쓰기의 경우 읽기와는 다르게 구조체 필드가 내보내기(Export)되지 않았을 경우(=앞 글자가 대문자가 아닐 경우) 패닉이 발생하므로 주의해야 합니다.\n","permalink":"https://blog.dfkdream.dev/2019/04/05/struct-indexing-in-go/","summary":"리플렉션 (reflect 패키지) 를 사용하면 구조체를 배열처럼 인덱스로 접근할 수 있습니다. import( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strconv\u0026#34; ) type test struct{ A int B int C string } 값 읽기 t := test{1,2,\u0026#34;3\u0026#34;} fmt.Println(reflect.ValueOf(t).Field(0).Int()) fmt.Println(reflect.ValueOf(t).Field(1).Int()) fmt.Println(reflect.ValueOf(t).Field(2).String()) 결과 1 2 3 자료형이 일치","title":"[Golang] 구조체 필드를 배열처럼 접근하기"},{"content":"데이터와 행 이름을 리스트로 넣으면 표를 출력해 주는 함수입니다.\n한글을 포맷팅하면 전각 한글을 한 글자로 계산해 표가 제대로 출력되지 않는데, 해당 문제를 해결해 두었습니다. 다른 전각 문자를 사용하려면 reKo 부분에 해당 문자 구간을 추가하면 됩니다.\n제어 문자열 \u0026quot;SEP\u0026quot;를 데이터 리스트에 포함시키면 행 구분을 출력합니다.\nSource Code import re def drawTable(identifiers,datas): reKo=re.compile(\u0026#34;[가-힣]\u0026#34;) maxLength=[len(str(x))+len(reKo.findall(str(x))) for x in identifiers] for data in datas: for index,d in enumerate(data): if d==\u0026#34;SEP\u0026#34;: continue if maxLength[index]\u0026lt;len(str(d))+len(reKo.findall(str(d))): maxLength[index]=len(str(d))+len(reKo.findall(str(d))) divider=\u0026#34;-\u0026#34;*(sum(maxLength)+(len(maxLength)+1)+len(maxLength)*2) print(divider) formatString=\u0026#34;|\u0026#34;+\u0026#34;\u0026#34;.join([\u0026#34; {0}{1}:^{2}{3} |\u0026#34;.format(\u0026#34;{\u0026#34;,index,length-len(reKo.findall(str(identifiers[index]))),\u0026#34;}\u0026#34;) for index,length in enumerate(maxLength)]) print(formatString.format(*identifiers)) print(divider) for data in datas: if data==\u0026#34;SEP\u0026#34;: print(divider) continue formatString=\u0026#34;|\u0026#34;+\u0026#34;\u0026#34;.join(\u0026#34; {0}{1}:^{2}{3} |\u0026#34;.format(\u0026#34;{\u0026#34;,index,length-len(reKo.findall(str(data[index]))),\u0026#34;}\u0026#34;) for index,length in enumerate(maxLength)) print(formatString.format(*data)) print(divider) 실행 예시 drawTable([\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;합계\u0026#34;],[[1,2,3],[4,5,9],\u0026#34;SEP\u0026#34;,[5000,5000,10000]]) Output 주의: 고정폭 폰트를 사용해야 표가 제대로 표시됩니다.\n----------------------- | a | b | 합계 | ----------------------- | 1 | 2 | 3 | | 4 | 5 | 9 | ----------------------- | 5000 | 5000 | 10000 | ----------------------- ","permalink":"https://blog.dfkdream.dev/2018/09/19/draw-table-in-python/","summary":"데이터와 행 이름을 리스트로 넣으면 표를 출력해 주는 함수입니다. 한글을 포맷팅하면 전각 한글을 한 글자로 계산해 표가 제대로 출력되지 않는데, 해당 문제를 해결해 두","title":"Python3 CLI 스크립트에서 표 그리기"},{"content":"Golang으로 애플리케이션 개발을 하면서 HTML 파서를 사용할 일이 가끔 있었습니다. golang.org/x/net/html 파서는 Python의 BeautifulSoup처럼 사용하기 편하게 구성되어 있지 않아 사용법을 간단히 정리해 보았습니다.\nCodes 예제 코드의 실행 결과에는 아래 HTML 노드를 사용했습니다. 편의상 예제 코드에서는 생략하도록 하겠습니다.\n아래 코드는 HTML 문서 전체가 아닌 노드 일부입니다. 문서 전체가 아닌 일부만을 html.Parse 함수에 전달할 경우 파서가 누락된 노드들(\u0026lt;html\u0026gt;,\u0026lt;head\u0026gt;,\u0026lt;body\u0026gt;등)을 알아서 추가합니다.\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; HTML 노드 렌더링 (renderNode) Code 아래 예시 소스코드들에서 사용되는 함수입니다. stackoverflow를 참고했습니다.\nfunc renderNode(n *html.Node) string { var buf bytes.Buffer w := io.Writer(\u0026amp;buf) html.Render(w, n) return buf.String() } 결과 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 하위 노드 전체 렌더링하기 Code var result =\u0026#34;\u0026#34; for d := n.FirstChild; d != nil; d = d.NextSibling { result += renderNode(d) } 결과 \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; 자식 노드 전체 탐색 HTML 파싱에는 일반적으로 이 코드를 사용합니다. 자식 노드 전체를 재귀적으로 탐색합니다.\nCode var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode{ fmt.Println(n.Data) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 ul li li li a 특정 자식 노드의 Text 읽기 Code var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data==\u0026#34;li\u0026#34;{ fmt.Println(n.FirstChild.Data) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 Item 1 Item 2 a Item 1과 Item 2의 경우 해당 텍스트 노드가 \u0026lt;li\u0026gt; 태그의 첫 번째 자식 노드(FirstChild)이기 때문에 정상적으로 출력될 수 있었습니다. 그렇지만 Item 3의 경우 \u0026lt;li\u0026gt; 태그의 첫 번째 자식 노드가 텍스트 노드가 아닌 \u0026lt;a\u0026gt; 태그이기 때문에 Item 3가 아닌 a가 출력이 되었습니다. 이러한 경우를 방지하기 위해 n.FirstChild.Data 대신 renderNode 함수를 사용합니다.\nCode (renderNode 함수 사용) var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data==\u0026#34;li\u0026#34;{ fmt.Println(renderNode(n.FirstChild)) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 Item 1 Item 2 \u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt; 다만, renderNode를 사용할 경우 파싱 결과에 HTML이 포함됩니다. 파싱 결과에 HTML이 포함되어도 되는 경우에만 사용할 수 있겠습니다.\nAttribute 값 읽기 Code var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data==\u0026#34;a\u0026#34;\u0026amp;\u0026amp; len(n.Attr)\u0026gt;0\u0026amp;\u0026amp;n.Attr[0].Key==\u0026#34;href\u0026#34;{ fmt.Println(n.Attr[0].Val) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 http://www.example.com len(n.Attr)\u0026gt;0을 추가하지 않을 경우 Attribute가 없는 태그(예시의 경우 \u0026lt;a\u0026gt;)를 만났을 때 runtime error: index out of range Panic이 발생합니다.\nnet/html 파서를 사용하기 불편하다면 goquery 등의 다른 라이브러리를 사용하는 것도 좋겠습니다.\n변경 기록 2023-02-09\nrenderNode 함수의 위치를 문서 최상위로 변경했습니다. 의견 주신 @mingkyme 님 감사합니다. ","permalink":"https://blog.dfkdream.dev/2018/09/15/using-golang-net-html-parser/","summary":"Golang으로 애플리케이션 개발을 하면서 HTML 파서를 사용할 일이 가끔 있었습니다. golang.org/x/net/html 파서는 Python의 BeautifulSoup처럼 사용하기 편하게","title":"Golang HTML 파서 사용하기"},{"content":"#include \u0026lt;stdio.h\u0026gt; int main(){ int i=0; scanf(\u0026#34;%d\\n\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); return 0; } scanf는 문자가 매칭이 안 되고 다음 문자가 whitespace가 아닐 때 까지 읽고 문자열이 남을 경우 나머지를 버퍼에 남긴다.\nscanf에 \\n이 들어갈 경우 줄바꿈이 매칭되므로 scanf가 종료되지 않고 다음 readable character가 들어올 때 까지 대기한다.\n이 예시의 경우 format string에 conversion specification이 하나밖에 없으므로 첫 readable character을 i에 쓰고 버퍼에 다음 character를 남긴다. 그래서 다음 scanf() 호출 시에 아무것도 입력하지 않아도 그 전에 입력했던 문자열을 버퍼에서 읽어와 출력하게 된다.\n(K\u0026amp;K 2/E p.46 참고)\n결론: scanf 끝에 줄바꿈 문자를 넣지 말자\n특별한 상황에서는 쓸 수도 있겠지만\u0026hellip; :)\n","permalink":"https://blog.dfkdream.dev/2018/09/12/do-not-use-line-feed-in-scanf/","summary":"#include \u0026lt;stdio.h\u0026gt; int main(){ int i=0; scanf(\u0026#34;%d\\n\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); return 0; } scanf는 문자가 매칭이 안 되고 다음 문자가 whitespace가 아닐 때 까지 읽고 문자열이 남을 경우 나머지를 버퍼에 남긴다.","title":"scanf()의 format string에 줄바꿈을 사용하면 안 되는 이유"},{"content":"뭐하지??\n","permalink":"https://blog.dfkdream.dev/2018/09/10/first-post/","summary":"뭐하지??","title":"Github pages 첫번째 포스트"}]