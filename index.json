[{"content":"태스크는 파일 처리 등 IO 작업을 요청한 다음 대기 상태에 들어가고, 처리가 완료되면 깨어나 남은 작업을 수행한다. 너무나 당연한 과정이라 인식하고 있지도 않았지만, 리눅스 커널은 이 작업을 여러 가지 단계들로 나누어 수행하고 있다.\n대기 대기 상태는 시그널 처리가 가능한 TASK_INTERRUPTIBLE와 시그널 처리가 불가능한TASK_UNINTERRUPTIBLE 두 가지 상태로 나누어진다. 이 상태에 들어간 태스크는 대기열에 자신의 구조체를 두고, 인터럽트가 발생하기를 기다리게 된다.\n깨우기 인터럽트가 발생하면 커널은 대기열에 들어가 있는 모든 태스크를 깨운다. 깨어난 태스크는 발생한 이벤트와 자신이 깨어날 조건을 비교해 작업을 계속 수행할지, 아니면 대기열에 다시 들어갈지를 결정한다. 커널이 조건을 직접 확인해 스레드를 깨우는 것이 더 효율적으로 보이지만 이런 방식이 채택된 이유는 깨어날 조건이 매우 복잡할 수도 있기 때문이다.\ninotify_read 대기 및 깨우기 과정을 잘 보여주는 inotify_read 함수를 분석해 보자.\n출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/fs/notify/inotify/inotify_user.c\nstatic ssize_t inotify_read(struct file *file, char __user *buf, size_t count, loff_t *pos) { struct fsnotify_group *group; struct fsnotify_event *kevent; char __user *start; int ret; DEFINE_WAIT_FUNC(wait, woken_wake_function); start = buf; group = file-\u0026gt;private_data; add_wait_queue(\u0026amp;group-\u0026gt;notification_waitq, \u0026amp;wait); while (1) { spin_lock(\u0026amp;group-\u0026gt;notification_lock); kevent = get_one_event(group, count); spin_unlock(\u0026amp;group-\u0026gt;notification_lock); pr_debug(\u0026#34;%s: group=%p kevent=%p\\n\u0026#34;, __func__, group, kevent); if (kevent) { ret = PTR_ERR(kevent); if (IS_ERR(kevent)) break; ret = copy_event_to_user(group, kevent, buf); fsnotify_destroy_event(group, kevent); if (ret \u0026lt; 0) break; buf += ret; count -= ret; continue; } ret = -EAGAIN; if (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) break; ret = -ERESTARTSYS; if (signal_pending(current)) break; if (start != buf) break; wait_woken(\u0026amp;wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); } remove_wait_queue(\u0026amp;group-\u0026gt;notification_waitq, \u0026amp;wait); if (start != buf \u0026amp;\u0026amp; ret != -EFAULT) ret = buf - start; return ret; } DEFINE_WAIT_FUNC 출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/include/linux/wait.h\n#define DEFINE_WAIT_FUNC(name, function)\t\\ struct wait_queue_entry name = {\t\\ .private\t= current,\t\\ .func\t= function,\t\\ .entry\t= LIST_HEAD_INIT((name).entry),\t\\ } DEFINE_WAIT_FUNC 매크로는 대기열 (wait_queue) 안에 들어갈 wait_queue_entry 구조체를 선언하고 있다. 이 매크로는 private, func, entry 세 개의 필드를 초기화한다. private 필드에는 현재 태스크의 task_struct가, func 필드에는 깨어난 직후 실행할 함수가 (이 경우에는 woken_wake_func), entry에는 이중 연결 리스트 구조체가 들어간다.\nwoken_wake_func 출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/wait.c\nint woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key) { /* Pairs with the smp_store_mb() in wait_woken(). */ smp_mb(); /* C */ wq_entry-\u0026gt;flags |= WQ_FLAG_WOKEN; return default_wake_function(wq_entry, mode, sync, key); } woken_wake_function은 wait_queue_entry의 WQ_FLAG_WOKEN플래그 비트를 1로 변경하고 default_wake_function을 호출한다. 이 플래그는 태스크가 방금 막 깨어났다는 것을 의미한다.\n출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/core.c\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags, void *key) { WARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) \u0026amp;\u0026amp; wake_flags \u0026amp; ~(WF_SYNC|WF_CURRENT_CPU)); return try_to_wake_up(curr-\u0026gt;private, mode, wake_flags); } default_wake_function은 try_to_wake_up을 실행시키고, 이 함수는 ttwu 함수들을 호출해 태스크를 이전에 실행되던 프로세서의 runqueue에 다시 삽입한다.\nadd_wait_queue 이렇게 만들어진 wait_queue_entry를 파일 기술자의 대기 큐에 삽입한 다음, 태스크는 while(1) 루프에 진입한다. 이 루프 안에서 태스크는 wait_woken을 호출해 이벤트가 발생할 때까지 대기 상태에 들어간다.\n인터럽트 발생 인터럽트가 발생되면 가장 먼저 woken_wake_function이 실행되고, 깨어난 태스크는 get_one_event 함수를 통해 이벤트를 가져오려고 시도한다. 이벤트를 가져오는 데 성공한 경우, 가져온 이벤트를 사용자 메모리에 복사하고 remove_wait_queue를 사용해 대기열에서 자신의 wait_queue_entry를 삭제해 대기를 종료한다. 만약 이벤트를 가져오지 못했다면 wait_woken 함수를 실행해 다시 대기 상태에 들어간다.\nwait_woken 출처: https://github.com/torvalds/linux/blob/1acfd2bd3f0d9dc34ea1871a445c554220945d9f/kernel/sched/wait.c\nlong wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout) { /* * The below executes an smp_mb(), which matches with the full barrier * executed by the try_to_wake_up() in woken_wake_function() such that * either we see the store to wq_entry-\u0026gt;flags in woken_wake_function() * or woken_wake_function() sees our store to current-\u0026gt;state. */ set_current_state(mode); /* A */ if (!(wq_entry-\u0026gt;flags \u0026amp; WQ_FLAG_WOKEN) \u0026amp;\u0026amp; !kthread_should_stop_or_park()) timeout = schedule_timeout(timeout); __set_current_state(TASK_RUNNING); /* * The below executes an smp_mb(), which matches with the smp_mb() (C) * in woken_wake_function() such that either we see the wait condition * being true or the store to wq_entry-\u0026gt;flags in woken_wake_function() * follows ours in the coherence order. */ smp_store_mb(wq_entry-\u0026gt;flags, wq_entry-\u0026gt;flags \u0026amp; ~WQ_FLAG_WOKEN); /* B */ return timeout; } wait_woken 함수는 가장 먼저 set_current_state 함수가 실행하고, 현재 태스크의 상태를 TASK_INTERRUPTIBLE 또는 TASK_UNINTERRUPTIBLE 상태로 바꾸어 대기 상태로 들어가게 한다.\n!(wq_entry-\u0026gt;flags \u0026amp; WQ_FLAG_WOKEN) \u0026amp;\u0026amp; !kthread_should_stop_or_park() 표현식은 태스크가 대기열 안에서 대기하고 있는 동안 다른 태스크의 호출로 인해 활성화되었을 경우 참이 된다. 이럴 경우 다른 태스크에게 프로세서를 양보하고 timeout만큼 다시 대기한다.\n인터럽트에 의해 깨어났을 경우, __set_current_state 함수를 호출해 태스크의 상태를 TASK_RUNNING으로 변경한다. 함수명 앞의 __는 이 함수를 smp_mb로 보호받고 있는 안전한 환경에서만 실행해야 한다는 것을 의미한다.\n그 후, smp_store_mb함수를 호출해 wait_queue_entry의 WQ_FLAG_WOKEN비트를 0으로 변경한다. 이렇게 태스크를 깨우는 프로세스가 끝나고, 실행된 태스크는 while(1) 루프 안에서 실행 조건을 검사해 처리를 계속할지, 아니면 다시 대기할지를 결정하게 된다.\n정리 실행 과정을 다시 정리해 보면 다음과 같다.\ninotify_read -\u0026gt; add_wait_queue -\u0026gt; wait_woken -\u0026gt; woken_wake_func -\u0026gt; ttwu -\u0026gt; 실행 조건 검사 -\u0026gt; wait_woken / remove_wait_queue 이 과정에서 WQ_FLAG_WOKEN 비트의 변화는 다음과 같다.\ncall inotify_read add_wait_queue wait_woken woken_wake_func inotify_read remove_wait_queue WQ_FLAG_WOKEN 0 0 0 1 1 0 실습 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/inotify.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define EVENT_SIZE (sizeof(struct inotify_event)) #define BUF_LEN (1024 * (EVENT_SIZE + 16)) int main(void){ int fd = inotify_init(); int wd = inotify_add_watch(fd, \u0026#34;.\u0026#34;, IN_MODIFY|IN_CREATE|IN_DELETE); int pid = fork(); printf(\u0026#34;pid %d created\\n\u0026#34;, pid); char buffer[BUF_LEN]; printf(\u0026#34;pid %d before_read\\n\u0026#34;, pid); int len = read(fd, buffer, BUF_LEN); printf(\u0026#34;pid %d after_read\\n\u0026#34;, pid); for (int i=0; i\u0026lt;len;){ struct inotify_event *event = (struct inotify_event *) \u0026amp;buffer[i]; if (event-\u0026gt;len){ if (event-\u0026gt;mask \u0026amp; IN_CREATE) { printf(\u0026#34;The file %s was created.\\n\u0026#34;, event-\u0026gt;name); } else if (event-\u0026gt;mask \u0026amp; IN_DELETE) { printf(\u0026#34;The file %s was deleted.\\n\u0026#34;, event-\u0026gt;name); } else if (event-\u0026gt;mask \u0026amp; IN_MODIFY) { printf(\u0026#34;The file %s was modified.\\n\u0026#34;, event-\u0026gt;name); } } i += EVENT_SIZE + event-\u0026gt;len; } } 동일한 대기 큐를 두 개의 태스크가 공유하도록 하기 위해 inotify_init으로 파일 기술자를 가져온 후 fork를 수행하여 동일한 파일 기술자에 두 번의 read를 수행하게 하였다.\npid 1028216 created pid 1028216 before_read pid 0 created pid 0 before_read pid 0 after_read The file test was created. pid 1028216 after_read The file test was deleted. 테스트 결과 첫 번째 inotify 이벤트에서는 대기 큐의 가장 처음에 위치한 (=가장 마지막에 들어간) 자식 태스크가 실행되었으며 두 번째 이벤트에서는 부모 태스크가 실행된 것을 확인할 수 있었다.\n참고문헌 https://stackoverflow.com/questions/13351172/inotify-file-in-c ","permalink":"https://blog.dfkdream.dev/2023/10/23/how-linux-task-sleep-and-wake-up/","summary":"태스크는 파일 처리 등 IO 작업을 요청한 다음 대기 상태에 들어가고, 처리가 완료되면 깨어나 남은 작업을 수행한다. 너무나 당연한 과정이라 인식하고 있지도 않았지만,","title":"리눅스 태스크가 대기하고 깨어나는 방법"},{"content":"리눅스 커널에서는 태스크 목록 등을 관리하기 위해 이중 연결 리스트가 사용되는데, 이 이중 연결 리스트는 중복 코드를 최대한 줄이기 위해 독특한 형태로 구성되어 있다.\n일반적인 이중 연결 리스트 struct list_head{ data_t payload; struct list_head *next, *prev; }; 이중 연결 리스트는 일반적으로 payload와 이전, 이후 노드를 가리키는 포인터들로 구성되어 있다. 이러한 구조체가 몇 개 밖에 없다면 큰 문제가 되지 않는다. 하지만 리눅스 커널처럼 복잡한 코드의 경우 여러 타입의 이중 연결 리스트가 매우 많이 필요하고 타입의 개수 만큼의 insert, delete, 순회 함수 등을 구현해야 한다.\n리눅스 커널의 이중 연결 리스트 이를 해결하기 위해 리눅스 커널에서는 이중 연결 리스트 구조체를 다음과 같이 정의하고 있다.\nstruct list_head{ struct list_head *next, *prev; }; 이 리스트를 위한 초기화, 삽입, 순회 함수/매크로는 다음과 같다.\n(실제 커널에서 사용되는 코드와 다릅니다)\n// 초기화 #define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) } // 삽입 void list_add(struct list_head *new, struct list_head *head){ new-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next-\u0026gt;prev = new; head-\u0026gt;next = new; } // 순회 #define LIST_FOR_EACH(pos, head) for (pos = head-\u0026gt;next; pos!=head; pos = pos-\u0026gt;next) 일반적인 이중 연결 리스트와는 다르게, 이 구조체에는 페이로드 필드가 빠져 있다. 그렇다면 이 구조체를 어떻게 사용할 수 있을까?\n리스트 필드를 포함하는 구조체에 접근하기 리눅스 커널은 list_head 구조체를 포함하고 있는 구조체의 주소를 계산하는 접근 방식을 취하고 있다.\n한 구조체 내에서 필드의 위치를 구하는 방법은 다음과 같다.\n#define offsetof(TYPE, MEMBER) ((size_t)\u0026amp;((TYPE *)0)-\u0026gt;MEMBER) 이 매크로는 TYPE 구조체가 0번지에서 시작된다고 가정하고, MEMBER 필드의 주소를 가져온다. 이 계산 결과는 결국 필드의 오프셋 값과 같다.\n오프셋 값을 이용하면 해당 필드를 담고 있는 구조체의 주소 값을 역산할 수 있다.\n#define container_of(ptr, type, member) ({ \\ const typeof(((type *)0)-\u0026gt;member) *__mptr = (ptr); \\ (type *)((char *)__mptr - offsetof(type, member)); }) 이 매크로의 두 번째 줄은 컴파일 시간에 타입을 검사하고 경고를 발생시키기 위해 사용된다.\n테스트 프로그램 이 매크로들을 사용하면 다음과 같이 리스트를 만들고 순회하는 테스트 프로그램을 작성할 수 있다.\n#include \u0026lt;stdio.h\u0026gt; #define offsetof(TYPE, MEMBER) ((size_t)\u0026amp;((TYPE *)0)-\u0026gt;MEMBER) #define container_of(ptr, type, member) ({ \\ const typeof(((type *)0)-\u0026gt;member) *__mptr = (ptr); \\ (type *)((char *)__mptr - offsetof(type, member)); }) #define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) } #define LIST_FOR_EACH(pos, head) for (pos = head-\u0026gt;next; pos!=head; pos = pos-\u0026gt;next) struct list_head{ struct list_head *next, *prev; }; void list_add(struct list_head *new, struct list_head *head){ new-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next-\u0026gt;prev = new; head-\u0026gt;next = new; } struct list_entry{ int key; struct list_head list; }; int main(void){ struct list_entry e0 = { .key = 0, .list = LIST_HEAD_INIT(e0.list) }; struct list_entry e1 = { .key = 1 }; list_add(\u0026amp;(e1.list), \u0026amp;(e0.list)); struct list_entry e2 = { .key = 2 }; list_add(\u0026amp;(e2.list), \u0026amp;(e1.list)); struct list_head* list; struct list_head* current = \u0026amp;(e0.list); printf(\u0026#34;%p key=%d\\n\u0026#34;, current, e0.key); struct list_entry* entry; LIST_FOR_EACH(list, current){ entry = container_of(list, struct list_entry, list); printf(\u0026#34;%p key=%d\\n\u0026#34;, list, entry-\u0026gt;key); } } 실행 결과 0x7ffc9f409128 key=0 0x7ffc9f409148 key=1 0x7ffc9f409168 key=2 의도한 것과 같이 잘 실행됨을 확인할 수 있다.\n","permalink":"https://blog.dfkdream.dev/2023/10/18/linked-list-of-linux-kernel/","summary":"리눅스 커널에서는 태스크 목록 등을 관리하기 위해 이중 연결 리스트가 사용되는데, 이 이중 연결 리스트는 중복 코드를 최대한 줄이기 위해 독특한 형태로 구성되어 있다.","title":"리눅스 커널의 연결 리스트"},{"content":"옛날 옛적, 여기서 멀지 않은 왕국에서 왕은 두 명의 보좌관을 시험하기로 했다. 왕은 두 개의 기다란 구멍이 위에 나 있고, 조절 노브와 레버가 달린 반짝이는 금속 상자를 보여주며 \u0026ldquo;이것이 무엇이라고 생각하는가?\u0026rdquo; 라고 물었다.\n전기 기술자인 보좌관이 먼저 대답했다. \u0026ldquo;토스터입니다\u0026rdquo;.\n왕은 되물었다. \u0026ldquo;이 장치에 들어갈 임베디드 컴퓨터를 어떻게 디자인할 텐가?\u0026rdquo;\n\u0026ldquo;4비트 마이크로컨트롤러를 사용하면 굽기 조절 노브에서 흰색에서 석탄처럼 검은색까지 16가지의 값을 읽어오는 간단한 프로그램을 작성할 수 있을 겁니다. 이 값을 타이머 테이블의 인덱스로 사용해 언제 가열을 중단하고 빵이 튀어나오게 할 지 결정할 수 있을 테지요. 다음 주에 다시 오시면 작동하는 프로토타입을 보여 드리겠습니다.\u0026rdquo;\n소프트웨어 개발자인 두 번째 보좌관은 이 말을 듣고 전기 기술자의 좁은 식견에 탄식하며 말했다. \u0026ldquo;토스터는 빵을 토스트로 만들기만 하는 장치가 아닙니다. 냉동 와플을 데우는 데 쓸 수도 있죠. 전하께서 원하시는 것은 바로 아침 식사 조리기입니다. 이 장치는 더 많은 기능을 가질 필요가 있어요. 소시지와 베이컨을 굽고, 에그 스크램블을 만드는 그런 것들 말입니다. 토스트만을 만들 수 있는 토스터는 몇 년 안에 쓸모없는 물건이 될 거예요. 미래를 보셔야 합니다.\u0026rdquo;\n\u0026ldquo;물론 저에겐 더 지적인 해결책이 있습니다. 먼저, 아침 식사 클래스를 만듭니다. 이 클래스는 곡류, 육류, 난류 서브 클래스로 특수화될 수 있지요. 곡류 클래스는 토스트, 머핀, 팬케이크, 와플 클래스로, 육류 클래스는 소시지, 비엔나소시지, 베이컨 클래스로, 난류 클래스는 에그 스크램블, 삶은 계란, 수란, 계란 프라이와 여러 개의 오믈렛 클래스들로 한 번 더 특수화될 수 있습니다.\u0026rdquo;\n\u0026ldquo;햄 치즈 오믈렛 클래스는 특별한 주의가 필요합니다. 육류, 유제품, 난류 클래스의 특성들을 모두 상속받아야 하니까요. 다중 상속을 사용하지 않으면 이 문제를 해결할 수 없습니다. 프로그램은 실행 시간에 적절한 객체를 생성한 후 \u0026lsquo;조리되어라\u0026rsquo; 라는 메시지를 전송해야 합니다. 물론 이 메시지의 의미는 객체에 따라 다르게 해석되어야겠지요. 그렇지 않으면 토스트가 에그 스크램블처럼 조리될지도 모르니까요.\u0026rdquo;\n\u0026ldquo;복기해 보자면, 분석 단계에서는 이 장치가 모든 종류의 아침 식사를 조리해야 한다는 요구사항을 도출했고, 디자인 단계에서는 몇 가지 파생 요구 사항들을 찾아냈습니다. 예를 들면 다중 상속을 위해 객체 지향 언어를 사용해야 합니다. 사용자는 베이컨이 구워지는 동안 계란이 차가워지는 것을 원치 않을 테니 병행 프로세싱도 물론 요구되겠네요.\u0026rdquo;\n\u0026ldquo;사용자 인터페이스도 빼놓을 수 없지요. 음식을 기계 안으로 집어넣는 레버는 범용성이 떨어지고, 굽기 조절 노브는 명확성이 부족합니다. 사용자 친화적인 GUI를 구비하지 않은 상품은 팔리지 않을 거예요. 아침 식사 조리기가 켜지면, 화면에 카우보이 부츠가 표시되어야 합니다. 사용자가 부츠를 클릭하면 \u0026lsquo;UNIX v.8.3 부팅 중\u0026rsquo;이 표시되고요. (출시 시점쯤 되면 UNIX 8.3도 릴리즈되어 있겠죠?) 메뉴를 열고 원하는 음식을 클릭하면 조리가 시작됩니다.\u0026rdquo;\n\u0026ldquo;디자인 단계에서 현명한 결정을 내렸으니 남은 것은 구현 단계에서 적절한 하드웨어 플랫폼을 결정하는 것뿐입니다. 인텔 펜티엄 프로세서와 48MB 메모리, 1.2GB 하드디스크, SVGA 모니터 정도면 충분하겠네요. 다중 상속과 멀티태스킹, GUI 지원이 내장된 객체 지향 언어를 선택한다면 프로그래밍은 식은 죽 먹기입니다.\u0026rdquo;\n지혜로운 왕은 소프트웨어 개발자의 목을 쳤고, 모두가 행복하게 오래오래 살았다고 한다.\nReference https://www.danielsen.com/jokes/objecttoaster.txt\n","permalink":"https://blog.dfkdream.dev/2023/08/16/object-oriented-toaster/","summary":"옛날 옛적, 여기서 멀지 않은 왕국에서 왕은 두 명의 보좌관을 시험하기로 했다. 왕은 두 개의 기다란 구멍이 위에 나 있고, 조절 노브와 레버가 달린 반짝이는 금속 상자를 보","title":"객체 지향 토스터"},{"content":"얼마 전에 MS Sculpt Ergonomic 마우스를 구입했고, 정말 잘 사용하고 있습니다. 하지만 이 마우스는 특이하게 앞으로 가기 버튼이 없고 Windows 키가 기본으로 할당되어 있습니다. 리눅스에서 이 키를 매핑할 수 있는 유틸리티가 제공되지 않아 다른 방법을 찾아 보았습니다.\n테스트 환경 Pop! OS 22.04 LTS (Ubuntu 22.04) 설치해야 하는 패키지 evemu-test evtest 마우스 정보 확인 sudo evemu describe bus, vendor, product 정보를 확인할 수 있습니다.\n이 마우스의 경우 bus는 0x03, vendor는 0x45e, product는 0x7a5입니다.\nhwdb 파일 작성에 필요하니 기록해 둡시다.\n특이하게도 MS Sculpt Ergonomic 마우스는 포인터 정보와 윈도우 버튼 정보를 다른 디바이스에서 전송합니다. 포인터 정보는 event4, 윈도우 버튼 정보는 event3.\n디바이스 파일 경로는 evtest 실행에 필요하니 기록해 둡시다.\nScancode 정보 확인 sudo evtest \u0026lt;디바이스 경로\u0026gt; 디바이스 경로는 마우스 정보 확인에서 찾을 수 있습니다.\n리매핑할 키를 여러번 누르고 (MSC_SCAN) 뒤의 value 를 확인합니다.\n이 마우스에서 윈도우 키의 스캔코드는 700e7입니다.\nhwdb 파일 작성 sudo vi /etc/udev/hwdb.d/10-ms-sculpt-remap.hwdb 첫 줄의 evdev:input:b\u0026lt;bus\u0026gt;v\u0026lt;vendor\u0026gt;p\u0026lt;product\u0026gt;* 로 장치 필터를 설정합니다.\nbus, vendor, product 값은 대문자 4자리 Hex 코드로 입력합니다.\nKEYBOARD_KEY_\u0026lt;scancode\u0026gt;=\u0026lt;keycode\u0026gt; 로 스캔코드에 리매핑할 키를 지정합니다.\nscancode는 소문자 Hex 코드로 입력합니다.\nkeycode는 /usr/include/linux/input-event-codes.h 파일에서 확인할 수 있습니다.\n#define KEY_ 뒤의 문자열을 소문자로 입력해 줍니다.\n","permalink":"https://blog.dfkdream.dev/2023/08/11/remapping-mouse-buttons-in-linux/","summary":"얼마 전에 MS Sculpt Ergonomic 마우스를 구입했고, 정말 잘 사용하고 있습니다. 하지만 이 마우스는 특이하게 앞으로 가기 버튼이 없고 Windows 키가 기본으로 할당되어 있습니다. 리눅스에","title":"리눅스에서 마우스 버튼 리매핑하기"},{"content":"Update: 2023.05.11\n외부 프로그램 없이 WikiLink를 변환해 주고 역링크도 추출해 주는 프로젝트인 hugo-wikilinks를 발견해 중단함. 잘 작동되면 문서 그래프 기능은 따로 구현해볼 수도 있을 것 같음.\n프로젝트 링크: https://github.com/dfkdream/obsidian_to_hugo\n개요 Obsidian은 내부 링크에 WikiLink 문법을 사용하는데, Hugo가 사용하는 Markdown 문법과 호환되지 않는다. Obsidian으로 작성된 문서를 바로 Hugo에 배포하고 싶어 이 프로젝트를 기획하게 되었다.\n목표 주 목표 WikiLink가 사용된 문서를 파싱해 Markdown 링크로 변환해 주는 Github Actions 개발\n부가 목표 매우 괜찮다고 생각하는 Obsidian 기능인 Graph View를 웹사이트 상에서도 사용할 수 있었으면 좋겠다. 문서 그래프를 작성해 json 형식으로 내보낼 수 있게 하기.\n분석 WikiLink 문법 Obsidian 자체도 markdown link로 변환 기능 을 제공하기는 한다. 하지만 Hugo로 빌드하는 경우 제대로 된 링크가 걸리지 않는 문제가 있다. Obsidian은 링크 생성 시 Hugo Permalink 설정을 참조하지 않기 때문이다. 이 부분이 주요 과제가 될 듯 하다.\nLink To File WikiLink [[file name.ext|alt]] Markdown [alt](file-name.ext) 기본 변환 기능 작동 여부: N Link To Image WikiLink ![[filename.ext|alt]] Markdown ![alt](filename.ext) 기본 변환 기능 작동 여부: N Link To Heading in a note WikiLink [[file name.ext#heading name|alt]] Markdown [alt](file-name.ext#heading-name) 기본 변환 기능 작동 여부: N Link To Block in a note WikiLink [[file name.ext#^uid|alt]] Markdown: 지원하지 않음 기본 변환 기능 작동 여부: N Note: 사용 시 지정된 블럭 마지막 단어 뒤에 uid가 생성됨 (^uid). External Link WikiLink: 지원하지 않음 Markdown: [[#Link To File]]과 동일 구현 계획 Filename - Permalink Key-Value 페어 생성기 구현 Wikilink, Markdown 파서 구현 워크스페이스 컨버터 구현 Github Actions 구현 TBD? ","permalink":"https://blog.dfkdream.dev/2023/02/16/project-convert-obsidian-to-markdown/","summary":"Update: 2023.05.11 외부 프로그램 없이 WikiLink를 변환해 주고 역링크도 추출해 주는 프로젝트인 hugo-wikilinks를 발견해 중단함. 잘 작동되면 문서 그래프","title":"[중단 프로젝트] Obsidian으로 작성된 문서 Markdown으로 변환하기"},{"content":"Jekyll + Minimal Mistakes로 만들었던 블로그를 Hugo로 이전했습니다.\n왜 Hugo인가? 가장 큰 이유는, Ruby보다는 Hugo가 사용하는 언어인 Go에 경험이 많았기 때문입니다. 사실 이 점이 블로그 글 작성에 큰 영향을 미치지는 않습니다. 실제 사용시에는 Hugo cli 명령어 정도만 사용하니까요. 하지만 혹시 모를 문제 발생시에 해결하기 훨씬 수월할 것 같다는 안정감이 들었습니다. Hugo를 사용한 정적 웹사이트 개발 프로젝트를 수행했던 경험이 있고, Hugo가 사용하는 템플릿 언어인 text/template 을 자주 사용했습니다. macOS에서 빌드 속도가 Jekyll에 비해 매우 빠릅니다. Linux에서는 비슷한 성능을 보여줬지만, macOS의 경우 Jekyll은 체감 빌드 시간이 1분 정도 걸리는 데 비해 Hugo는 대략 3초 이내로 빌드가 완료됩니다. Hot Reload를 지원해 테마 개발이 편리합니다. Google Analytics, 목차 생성 기능 등 기본 제공되는 기능들이 풍부합니다. 테마를 git submodule로 관리해 소스트리가 깔끔합니다. 단점은? Github pages에서 기본적으로 지원하지 않습니다. Jekyll의 경우, 별도 설정 없이 페이지 빌드와 배포가 자동으로 수행되는 반면, Hugo의 경우 Github Actions를 수동으로 설정해 주어야 합니다. 단점이 별로 없는 것 같지만, 위 단점이 생각보다 많이 컸습니다. 그래서 사실 Go를 많이 좋아하고, 경험이 있는 것이 아니라면 그냥 Jekyll을 사용하는 것이 나을지도 모르겠네요.\nHugo를 사용한 또 다른 이유에는 PaperMod 테마를 사용하기 위한 것도 있었습니다. 미니멀한 디자인이고, 퍼지 검색 기능을 기본적으로 지원한다는 점이 마음에 들었어요.\n이전 과정 1. Hugo 초기화 및 기존 블로그 정리 먼저, 기존 블로그 디렉토리에서 Hugo 사이트를 생성했습니다. 디렉토리가 비어 있지 않기 때문에 --force를 사용해 강제로 초기화합니다.\nhugo new site . --force 그런 다음, 기존 포스트 파일들을 content/posts 디렉토리로 이동하고, 파일명 앞에 붙어 있던 날짜를 제거해 주었습니다. Hugo가 permalink 생성에 파일명을 사용하기 때문인데, 개인적으로는 날짜를 붙일 수 있는 Jekyll 방식이 더 마음에 듭니다. 파일명 정렬이 쉬워지니까요. Hugo에서도 이 방식을 사용할 수 있는지 찾아보아야겠습니다. 혹시 아시는 분 있으시면 댓글에 알려주세요.\nfor file in *; do mv $file $(echo $file | cut -c12-) ; done 루트 디렉터리에 두었던 CNAME, favicon.ico 파일 등은 static 디렉토리로 이동합니다.\n2. 테마 및 Hugo 설정 themes 폴더 아래에 테마 리포지터리를 git submodule로 추가해 줍니다. 저는 PaperMod를 사용했습니다.\ngit submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 테마의 config.yml파일을 참고해 Hugo를 설정해 줍니다. 주요 수정 내용은 다음과 같습니다.\n# 읽기 시간 계산등에 한국어에 맞는 계산법 적용 hasCJKLanguage: true # fuse 검색을 위해 JSON 인덱스 생성 outputs: home: - HTML - RSS - JSON # SEO를 위해 Jekyll과 동일하게 permalink 생성 permalinks: posts: /:2006/:01/:02/:filename 3. Github Actions 설정 Hugo 문서를 참고해 .github/workflows/gh-pages.yml 파일을 작성했습니다. 주의할 점은 on 설정과 Deploy step의 if에 브랜치 이름이 main으로 하드코딩되어 있다는 점입니다. 제 블로그는 master브랜치를 사용하기 때문에, 문서에 있는 파일을 그대로 사용했을 때 제대로 빌드되지 않는 문제가 발생했습니다.\n빌드가 완료되면 결과물이 gh-pages 브랜치에 푸시됩니다. 이 브랜치를 github pages 배포에 사용하도록 프로젝트를 설정합니다. ","permalink":"https://blog.dfkdream.dev/2023/02/13/migrate-jekyll-blog-to-hugo/","summary":"Jekyll + Minimal Mistakes로 만들었던 블로그를 Hugo로 이전했습니다. 왜 Hugo인가? 가장 큰 이유는, Ruby보다는 Hugo가 사용하는 언어인 Go에 경","title":"Jekyll 블로그 Hugo로 이전한 후기"},{"content":"Github 등 Git 서버에서는 커미터가 자신임을 증명하기 위해 GPG 서명을 사용할 수 있습니다. 이때 사용되는 GPG 키는 보안을 위해 유효기간을 지정하는 것이 권장되는데, 유효기간이 지나면 해당 키로 커밋을 할 수 없는 등 문제가 발생합니다.\n이런 문제가 발생했을 때 GPG 키를 갱신하는 방법입니다.\n테스트 환경 macOS Monterey gpg (GnuPG) 2.3.4 저장된 키 목록 확인 gpg --list-keys \u0026lt;keybox 파일 경로\u0026gt; ---------------------------------- pub rsa4096 \u0026lt;생성일\u0026gt; [SC] [expires: \u0026lt;만료일\u0026gt;] \u0026lt;Key ID\u0026gt; uid [ultimate] \u0026lt;username\u0026gt; \u0026lt;\u0026lt;email\u0026gt; sub rsa4096 \u0026lt;생성일\u0026gt; [E] [expires: \u0026lt;만료일\u0026gt;] Key ID는 유효기간 연장을 위해 필요하니 잘 확인하시기 바랍니다.\n키 유효기간 연장 gpg --edit-key \u0026lt;Key ID\u0026gt; 아무것도 입력하지 않으면 Primary key를 수정하게 됩니다.\ngpg\u0026gt; expire Changing expiration time for the primary key. Please specify how long the key should be valid. 0 = key does not expire \u0026lt;n\u0026gt; = key expires in n days \u0026lt;n\u0026gt;w = key expires in n weeks \u0026lt;n\u0026gt;m = key expires in n months \u0026lt;n\u0026gt;y = key expires in n years Key is valid for? (0) n+단위를 입력해 만료일을 오늘 날짜로부터 n만큼 연장시킵니다.\nSubkey의 유효기간도 연장시켜 줍시다.\ngpg\u0026gt; key 1 gpg\u0026gt; expire 이후의 명령은 Primary key와 동일합니다.\n마지막으로 수정 내용을 저장합니다.\ngpg\u0026gt; save 공개키 내보내기 gpg --armor --export \u0026lt;Key ID\u0026gt; 지정된 키를 텍스트 형식으로 내보냅니다. 표준 출력으로 키 내용이 출력되니 리디렉션을 사용해 클립보드에 바로 복사할 수도 있습니다.\n이제 Git 서버 관리 페이지에서 기존 공개키를 삭제하고 내보낸 키를 다시 등록하면 됩니다.\n","permalink":"https://blog.dfkdream.dev/2022/03/30/renewing-expired-gpg-key/","summary":"Github 등 Git 서버에서는 커미터가 자신임을 증명하기 위해 GPG 서명을 사용할 수 있습니다. 이때 사용되는 GPG 키는 보안을 위해 유효기간을 지정하는 것이 권장되는데, 유효기간","title":"만료된 GPG 키 갱신하기 (유효기간 연장)"},{"content":"pyenv, pyenv-virtualenv 설치 방법과 자주 사용되는 명령어들을 모아 보았습니다.\n테스트 환경 macOS Monterey iTerm2 ZSH pyenv 설치 brew install pyenv echo \u0026#39;eval \u0026#34;$(pyenv init --path)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zprofile echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 특정 버전의 python 설치 pyenv install \u0026lt;python-version\u0026gt; ex)\npyenv install 3.8.12 pyenv-virtualenv 설치 brew install pyenv-virtualenv echo \u0026#39;eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc virtualenv 생성 pyenv virtualenv \u0026lt;python-version\u0026gt; \u0026lt;venv-name\u0026gt; ex)\npyenv virtualenv 3.8.12 venv virtualenv 적용 pyenv activate \u0026lt;venv-name\u0026gt; ex)\npyenv activate venv 특정 폴더에 virtualenv 자동 적용 pyenv local \u0026lt;venv-name\u0026gt; ex)\npyenv local venv 실행 시 현재 디렉토리에 .python-version 파일이 생성되고 pyenv가 이 파일을 자동으로 인식해 가상 환경을 적용해 줍니다.\nvirtualenv 삭제 pyenv uninstall \u0026lt;venv-name\u0026gt; ex)\npyenv uninstall venv ","permalink":"https://blog.dfkdream.dev/2022/03/08/installing-and-using-pyenv-macos/","summary":"pyenv, pyenv-virtualenv 설치 방법과 자주 사용되는 명령어들을 모아 보았습니다. 테스트 환경 macOS Monterey iTerm2 ZSH pyenv 설치 brew install pyenv echo \u0026#39;eval \u0026#34;$(pyenv init --path)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zprofile echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 특정 버전의 python 설치 pyenv install \u0026lt;python-version\u0026gt; ex) pyenv install 3.8.12","title":"macOS에 pyenv 설치, 사용하기"},{"content":"zsh-autosuggestions와 zsh-syntax-highlighting은 zsh 사용을 엄청 편리하게 해 주는 플러그인입니다. 그런데 macOS에서 이 플러그인들을 설치했더니 플러그인 간에 충돌이 발생해 자동완성된 명령어가 보이지 않거나 하이라이팅이 제대로 되지 않는 문제가 발생했습니다. 이 포스트에서는 이런 문제들을 해결해 보겠습니다.\n테스트 환경 macOS Big Sur iTerm2 Build 3.3.7 oh-my-zsh 플러그인 설치 먼저 더 많은 명령어 자동 완성 목록을 사용하기 위해 zsh-completions를 설치해 줍시다.\n% git clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions 다음으로 zsh-syntax-highlighting과 zsh-autosuggestions를 설치해 주겠습니다.\n% git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting % git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 설치가 모두 끝나면 ~/.zshrc 파일을 다음과 같이 수정해 플러그인을 활성화해 주겠습니다.\nplugins=( [Plugins...] zsh-syntax-highlighting zsh-completions zsh-autosuggestions ) ... autoload -U compinit \u0026amp;\u0026amp; compinit 가장 마지막 줄의 autoload...는 zsh-completions 활성화를 위한 부분입니다. 파일 가장 마지막 줄에 추가해 줍시다.\n설치가 모두 끝났습니다! 마지막으로 다음 명령어를 입력해 설정 파일을 로드해 주겠습니다.\nsource ~/.zshrc 이러면 이제 자동완성과 문법 하이라이팅이 이쁘게 되어야 하는디\u0026hellip;\nTroubles 이대로 설정하면 데모에서 본 것처럼 표시가 되지 않습니다. 제 경우에는\n자동완성된 부분이 입력한 부분과 구분이 되지 않음 자동완성된 부분 글자가 하나만 보이고 나머지는 보이지 않음 이런 문제가 발생했습니다.\nTroubleshooting 자동완성된 부분이 입력한 부분과 구분이 되지 않음 먼저 1번 문제부터 고쳐 보겠습니다. 이 문제는 zsh-syntax-highlighting이 macOS Big Sur에 기본으로 설치된 zsh 5.8 (x86_64-apple-darwin20.0)을 인식하지 못해 발생하는 문제입니다. brew를 사용해 zsh를 업데이트(설치)해 줍시다.\n% brew install zsh 이제 터미널을 새로 열면 zsh가 업데이트된 것을 확인할 수 있습니다.\n% zsh --version zsh 5.8 (x86_64-apple-darwin20.1.0) (실행 시점과 OS버전 / 아키텍쳐에 따라 다를 수 있습니다.)\n이 문제는 이제 해결!\n자동완성된 부분 글자가 하나만 보이고 나머지는 보이지 않음 그런데.. 기본 테마가 아닌 Solarized Dark 등의 컬러 스킴을 사용하시는 경우 자동완성된 부분 글자가 제대로 보이지 않는 문제가 발생합니다. 이건 zsh-autosuggestions가 기본 자동완성 하이라이팅 색상으로 사용하는 ANSI Bright Black 색상이 Background 색상과 동일하게 설정되어 있어 생기는 문제입니다.\niTerm2 설정 (cmd+,) \u0026gt; Profiles \u0026gt; Colors \u0026gt; ANSI Colors \u0026gt; Black \u0026gt; Bright 색상을 다른 색으로 변경해 줍시다. 저의 경우 #2a5965로 설정했습니다.\n이러면 이제 진짜로 설정 끝!\n참고문헌 / 출처 본격 macOS에 개발 환경 구축하기 - Subicura\u0026rsquo;s Blog autosuggestion not working for oh-my-zsh #416 - zsh-users/zsh-autosuggestion Conflict with zsh-autosuggestions under zsh 5.8 (and only that version) #756 - zsh-users/zsh-syntax-highlighting ","permalink":"https://blog.dfkdream.dev/2020/02/21/zsh-autosuggest-with-highlight/","summary":"zsh-autosuggestions와 zsh-syntax-highlighting은 zsh 사용을 엄청 편리하게 해 주는 플러그인입니다. 그런데 ma","title":"zsh-autosuggest와 zsh-syntax-highlighting 충돌 문제 해결"},{"content":"리플렉션 (reflect 패키지) 를 사용하면 구조체를 배열처럼 인덱스로 접근할 수 있습니다.\nimport( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strconv\u0026#34; ) type test struct{ A int B int C string } 값 읽기 t := test{1,2,\u0026#34;3\u0026#34;} fmt.Println(reflect.ValueOf(t).Field(0).Int()) fmt.Println(reflect.ValueOf(t).Field(1).Int()) fmt.Println(reflect.ValueOf(t).Field(2).String()) 결과 1 2 3 자료형이 일치하지 않을 경우 패닉이 발생합니다.\nt := test{1,2,\u0026#34;3\u0026#34;} fmt.Println(reflect.ValueOf(t).Field(0).Int()) fmt.Println(reflect.ValueOf(t).Field(1).Int()) fmt.Println(reflect.ValueOf(t).Field(2).Int()) 결과 1 2 panic: reflect: call of reflect.Value.Int on string Value 그러므로 값을 읽기 전에는 Kind() 함수를 이용해 타입 검사를 해 주어야 합니다.\nt := test{1,2,\u0026#34;3\u0026#34;} for i:=0;i\u0026lt;3;i++{ if reflect.ValueOf(t).Field(i).Kind()==reflect.String{ fmt.Println(reflect.ValueOf(t).Field(i).String()) }else{ fmt.Println(reflect.ValueOf(t).Field(i).Int()) } } 결과 1 2 3 값 쓰기 var t test reflect.ValueOf(\u0026amp;t).Elem().Field(0).SetInt(int64(1)) reflect.ValueOf(\u0026amp;t).Elem().Field(1).SetInt(int64(2)) reflect.ValueOf(\u0026amp;t).Elem().Field(2).SetString(\u0026#34;3\u0026#34;) fmt.Println(t) 결과 {1 2 3} 값을 읽는 코드와 비슷합니다. 다만 구조체 필드의 값을 변경하기 위해 ValueOf 함수의 파라미터로 포인터를 넘겼고 역참조를 위해 Elem() 함수를 사용하고 있습니다.\n값 쓰기의 경우에도 읽기와 마찬가지로 자료형이 일치하지 않을 경우 패닉이 발생합니다.\nvar t test reflect.ValueOf(\u0026amp;t).Elem().Field(0).SetInt(int64(1)) reflect.ValueOf(\u0026amp;t).Elem().Field(1).SetInt(int64(2)) reflect.ValueOf(\u0026amp;t).Elem().Field(2).SetInt(int64(3)) fmt.Println(t) 결과 panic: reflect: call of reflect.Value.SetInt on string Value 그러므로 Kind() 함수를 이용해 타입 검사를 해 주어야 합니다.\nvar t test a:=[]int{1,2,3} for i,n:=range a{ if reflect.ValueOf(t).Field(i).Kind()==reflect.String{ reflect.ValueOf(\u0026amp;t).Elem().Field(i).SetString(strconv.Itoa(n)) }else{ reflect.ValueOf(\u0026amp;t).Elem().Field(i).SetInt(int64(n)) } } fmt.Println(t) 결과 {1 2 3} 쓰기의 경우 읽기와는 다르게 구조체 필드가 내보내기(Export)되지 않았을 경우(=앞 글자가 대문자가 아닐 경우) 패닉이 발생하므로 주의해야 합니다.\n","permalink":"https://blog.dfkdream.dev/2019/04/05/struct-indexing-in-go/","summary":"리플렉션 (reflect 패키지) 를 사용하면 구조체를 배열처럼 인덱스로 접근할 수 있습니다. import( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strconv\u0026#34; ) type test struct{ A int B int C string } 값 읽기 t := test{1,2,\u0026#34;3\u0026#34;} fmt.Println(reflect.ValueOf(t).Field(0).Int()) fmt.Println(reflect.ValueOf(t).Field(1).Int()) fmt.Println(reflect.ValueOf(t).Field(2).String()) 결과 1 2 3 자료형이 일치","title":"[Golang] 구조체 필드를 배열처럼 접근하기"},{"content":"데이터와 행 이름을 리스트로 넣으면 표를 출력해 주는 함수입니다.\n한글을 포맷팅하면 전각 한글을 한 글자로 계산해 표가 제대로 출력되지 않는데, 해당 문제를 해결해 두었습니다. 다른 전각 문자를 사용하려면 reKo 부분에 해당 문자 구간을 추가하면 됩니다.\n제어 문자열 \u0026quot;SEP\u0026quot;를 데이터 리스트에 포함시키면 행 구분을 출력합니다.\nSource Code import re def drawTable(identifiers,datas): reKo=re.compile(\u0026#34;[가-힣]\u0026#34;) maxLength=[len(str(x))+len(reKo.findall(str(x))) for x in identifiers] for data in datas: for index,d in enumerate(data): if d==\u0026#34;SEP\u0026#34;: continue if maxLength[index]\u0026lt;len(str(d))+len(reKo.findall(str(d))): maxLength[index]=len(str(d))+len(reKo.findall(str(d))) divider=\u0026#34;-\u0026#34;*(sum(maxLength)+(len(maxLength)+1)+len(maxLength)*2) print(divider) formatString=\u0026#34;|\u0026#34;+\u0026#34;\u0026#34;.join([\u0026#34; {0}{1}:^{2}{3} |\u0026#34;.format(\u0026#34;{\u0026#34;,index,length-len(reKo.findall(str(identifiers[index]))),\u0026#34;}\u0026#34;) for index,length in enumerate(maxLength)]) print(formatString.format(*identifiers)) print(divider) for data in datas: if data==\u0026#34;SEP\u0026#34;: print(divider) continue formatString=\u0026#34;|\u0026#34;+\u0026#34;\u0026#34;.join(\u0026#34; {0}{1}:^{2}{3} |\u0026#34;.format(\u0026#34;{\u0026#34;,index,length-len(reKo.findall(str(data[index]))),\u0026#34;}\u0026#34;) for index,length in enumerate(maxLength)) print(formatString.format(*data)) print(divider) 실행 예시 drawTable([\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;합계\u0026#34;],[[1,2,3],[4,5,9],\u0026#34;SEP\u0026#34;,[5000,5000,10000]]) Output 주의: 고정폭 폰트를 사용해야 표가 제대로 표시됩니다.\n----------------------- | a | b | 합계 | ----------------------- | 1 | 2 | 3 | | 4 | 5 | 9 | ----------------------- | 5000 | 5000 | 10000 | ----------------------- ","permalink":"https://blog.dfkdream.dev/2018/09/19/draw-table-in-python/","summary":"데이터와 행 이름을 리스트로 넣으면 표를 출력해 주는 함수입니다. 한글을 포맷팅하면 전각 한글을 한 글자로 계산해 표가 제대로 출력되지 않는데, 해당 문제를 해결해 두","title":"Python3 CLI 스크립트에서 표 그리기"},{"content":"Golang으로 애플리케이션 개발을 하면서 HTML 파서를 사용할 일이 가끔 있었습니다. golang.org/x/net/html 파서는 Python의 BeautifulSoup처럼 사용하기 편하게 구성되어 있지 않아 사용법을 간단히 정리해 보았습니다.\nCodes 예제 코드의 실행 결과에는 아래 HTML 노드를 사용했습니다. 편의상 예제 코드에서는 생략하도록 하겠습니다.\n아래 코드는 HTML 문서 전체가 아닌 노드 일부입니다. 문서 전체가 아닌 일부만을 html.Parse 함수에 전달할 경우 파서가 누락된 노드들(\u0026lt;html\u0026gt;,\u0026lt;head\u0026gt;,\u0026lt;body\u0026gt;등)을 알아서 추가합니다.\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; HTML 노드 렌더링 (renderNode) Code 아래 예시 소스코드들에서 사용되는 함수입니다. stackoverflow를 참고했습니다.\nfunc renderNode(n *html.Node) string { var buf bytes.Buffer w := io.Writer(\u0026amp;buf) html.Render(w, n) return buf.String() } 결과 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 하위 노드 전체 렌더링하기 Code var result =\u0026#34;\u0026#34; for d := n.FirstChild; d != nil; d = d.NextSibling { result += renderNode(d) } 결과 \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; 자식 노드 전체 탐색 HTML 파싱에는 일반적으로 이 코드를 사용합니다. 자식 노드 전체를 재귀적으로 탐색합니다.\nCode var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode{ fmt.Println(n.Data) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 ul li li li a 특정 자식 노드의 Text 읽기 Code var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data==\u0026#34;li\u0026#34;{ fmt.Println(n.FirstChild.Data) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 Item 1 Item 2 a Item 1과 Item 2의 경우 해당 텍스트 노드가 \u0026lt;li\u0026gt; 태그의 첫 번째 자식 노드(FirstChild)이기 때문에 정상적으로 출력될 수 있었습니다. 그렇지만 Item 3의 경우 \u0026lt;li\u0026gt; 태그의 첫 번째 자식 노드가 텍스트 노드가 아닌 \u0026lt;a\u0026gt; 태그이기 때문에 Item 3가 아닌 a가 출력이 되었습니다. 이러한 경우를 방지하기 위해 n.FirstChild.Data 대신 renderNode 함수를 사용합니다.\nCode (renderNode 함수 사용) var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data==\u0026#34;li\u0026#34;{ fmt.Println(renderNode(n.FirstChild)) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 Item 1 Item 2 \u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt; 다만, renderNode를 사용할 경우 파싱 결과에 HTML이 포함됩니다. 파싱 결과에 HTML이 포함되어도 되는 경우에만 사용할 수 있겠습니다.\nAttribute 값 읽기 Code var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data==\u0026#34;a\u0026#34;\u0026amp;\u0026amp; len(n.Attr)\u0026gt;0\u0026amp;\u0026amp;n.Attr[0].Key==\u0026#34;href\u0026#34;{ fmt.Println(n.Attr[0].Val) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 http://www.example.com len(n.Attr)\u0026gt;0을 추가하지 않을 경우 Attribute가 없는 태그(예시의 경우 \u0026lt;a\u0026gt;)를 만났을 때 runtime error: index out of range Panic이 발생합니다.\nnet/html 파서를 사용하기 불편하다면 goquery 등의 다른 라이브러리를 사용하는 것도 좋겠습니다.\n변경 기록 2023-02-09\nrenderNode 함수의 위치를 문서 최상위로 변경했습니다. 의견 주신 @mingkyme 님 감사합니다. ","permalink":"https://blog.dfkdream.dev/2018/09/15/using-golang-net-html-parser/","summary":"Golang으로 애플리케이션 개발을 하면서 HTML 파서를 사용할 일이 가끔 있었습니다. golang.org/x/net/html 파서는 Python의 BeautifulSoup처럼 사용하기 편하게","title":"Golang HTML 파서 사용하기"},{"content":"#include \u0026lt;stdio.h\u0026gt; int main(){ int i=0; scanf(\u0026#34;%d\\n\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); return 0; } scanf는 문자가 매칭이 안 되고 다음 문자가 whitespace가 아닐 때 까지 읽고 문자열이 남을 경우 나머지를 버퍼에 남긴다.\nscanf에 \\n이 들어갈 경우 줄바꿈이 매칭되므로 scanf가 종료되지 않고 다음 readable character가 들어올 때 까지 대기한다.\n이 예시의 경우 format string에 conversion specification이 하나밖에 없으므로 첫 readable character을 i에 쓰고 버퍼에 다음 character를 남긴다. 그래서 다음 scanf() 호출 시에 아무것도 입력하지 않아도 그 전에 입력했던 문자열을 버퍼에서 읽어와 출력하게 된다.\n(K\u0026amp;K 2/E p.46 참고)\n결론: scanf 끝에 줄바꿈 문자를 넣지 말자\n특별한 상황에서는 쓸 수도 있겠지만\u0026hellip; :)\n","permalink":"https://blog.dfkdream.dev/2018/09/12/do-not-use-line-feed-in-scanf/","summary":"#include \u0026lt;stdio.h\u0026gt; int main(){ int i=0; scanf(\u0026#34;%d\\n\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); return 0; } scanf는 문자가 매칭이 안 되고 다음 문자가 whitespace가 아닐 때 까지 읽고 문자열이 남을 경우 나머지를 버퍼에 남긴다.","title":"scanf()의 format string에 줄바꿈을 사용하면 안 되는 이유"},{"content":"뭐하지??\n","permalink":"https://blog.dfkdream.dev/2018/09/10/first-post/","summary":"뭐하지??","title":"Github pages 첫번째 포스트"}]