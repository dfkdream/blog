[{"content":"얼마 전에 MS Sculpt Ergonomic 마우스를 구입했고, 정말 잘 사용하고 있습니다. 하지만 이 마우스는 특이하게 앞으로 가기 버튼이 없고 Windows 키가 기본으로 할당되어 있습니다. 리눅스에서 이 키를 매핑할 수 있는 유틸리티가 제공되지 않아 다른 방법을 찾아 보았습니다.\n테스트 환경 Pop! OS 22.04 LTS (Ubuntu 22.04) 설치해야 하는 패키지 evemu-test evtest 마우스 정보 확인 sudo evemu describe bus, vendor, product 정보를 확인할 수 있습니다.\n이 마우스의 경우 bus는 0x03, vendor는 0x45e, product는 0x7a5입니다.\nhwdb 파일 작성에 필요하니 기록해 둡시다.\n특이하게도 MS Sculpt Ergonomic 마우스는 포인터 정보와 윈도우 버튼 정보를 다른 디바이스에서 전송합니다. 포인터 정보는 event4, 윈도우 버튼 정보는 event3.\n디바이스 파일 경로는 evtest 실행에 필요하니 기록해 둡시다.\nScancode 정보 확인 sudo evtest \u0026lt;디바이스 경로\u0026gt; 디바이스 경로는 마우스 정보 확인에서 찾을 수 있습니다.\n리매핑할 키를 여러번 누르고 (MSC_SCAN) 뒤의 value 를 확인합니다.\n이 마우스에서 윈도우 키의 스캔코드는 700e7입니다.\nhwdb 파일 작성 sudo vi /etc/udev/hwdb.d/10-ms-sculpt-remap.hwdb 첫 줄의 evdev:input:b\u0026lt;bus\u0026gt;v\u0026lt;vendor\u0026gt;p\u0026lt;product\u0026gt;* 로 장치 필터를 설정합니다.\nbus, vendor, product 값은 대문자 4자리 Hex 코드로 입력합니다.\nKEYBOARD_KEY_\u0026lt;scancode\u0026gt;=\u0026lt;keycode\u0026gt; 로 스캔코드에 리매핑할 키를 지정합니다.\nscancode는 소문자 Hex 코드로 입력합니다.\nkeycode는 /usr/include/linux/input-event-codes.h 파일에서 확인할 수 있습니다.\n#define KEY_ 뒤의 문자열을 소문자로 입력해 줍니다.\n","permalink":"https://blog.dfkdream.dev/2023/08/11/remapping-mouse-buttons-in-linux/","summary":"얼마 전에 MS Sculpt Ergonomic 마우스를 구입했고, 정말 잘 사용하고 있습니다. 하지만 이 마우스는 특이하게 앞으로 가기 버튼이 없고 Windows 키가 기본으로 할당되어 있습니다. 리눅스에","title":"리눅스에서 마우스 버튼 리매핑하기"},{"content":"Update: 2023.05.11\n외부 프로그램 없이 WikiLink를 변환해 주고 역링크도 추출해 주는 프로젝트인 hugo-wikilinks를 발견해 중단함. 잘 작동되면 문서 그래프 기능은 따로 구현해볼 수도 있을 것 같음.\n프로젝트 링크: https://github.com/dfkdream/obsidian_to_hugo\n개요 Obsidian은 내부 링크에 WikiLink 문법을 사용하는데, Hugo가 사용하는 Markdown 문법과 호환되지 않는다. Obsidian으로 작성된 문서를 바로 Hugo에 배포하고 싶어 이 프로젝트를 기획하게 되었다.\n목표 주 목표 WikiLink가 사용된 문서를 파싱해 Markdown 링크로 변환해 주는 Github Actions 개발\n부가 목표 매우 괜찮다고 생각하는 Obsidian 기능인 Graph View를 웹사이트 상에서도 사용할 수 있었으면 좋겠다. 문서 그래프를 작성해 json 형식으로 내보낼 수 있게 하기.\n분석 WikiLink 문법 Obsidian 자체도 markdown link로 변환 기능 을 제공하기는 한다. 하지만 Hugo로 빌드하는 경우 제대로 된 링크가 걸리지 않는 문제가 있다. Obsidian은 링크 생성 시 Hugo Permalink 설정을 참조하지 않기 때문이다. 이 부분이 주요 과제가 될 듯 하다.\nLink To File WikiLink [[file name.ext|alt]] Markdown [alt](file-name.ext) 기본 변환 기능 작동 여부: N Link To Image WikiLink ![[filename.ext|alt]] Markdown ![alt](filename.ext) 기본 변환 기능 작동 여부: N Link To Heading in a note WikiLink [[file name.ext#heading name|alt]] Markdown [alt](file-name.ext#heading-name) 기본 변환 기능 작동 여부: N Link To Block in a note WikiLink [[file name.ext#^uid|alt]] Markdown: 지원하지 않음 기본 변환 기능 작동 여부: N Note: 사용 시 지정된 블럭 마지막 단어 뒤에 uid가 생성됨 (^uid). External Link WikiLink: 지원하지 않음 Markdown: [[#Link To File]]과 동일 구현 계획 Filename - Permalink Key-Value 페어 생성기 구현 Wikilink, Markdown 파서 구현 워크스페이스 컨버터 구현 Github Actions 구현 TBD? ","permalink":"https://blog.dfkdream.dev/2023/02/16/project-convert-obsidian-to-markdown/","summary":"Update: 2023.05.11 외부 프로그램 없이 WikiLink를 변환해 주고 역링크도 추출해 주는 프로젝트인 hugo-wikilinks를 발견해 중단함. 잘 작동되면 문서 그래프","title":"[중단 프로젝트] Obsidian으로 작성된 문서 Markdown으로 변환하기"},{"content":"Jekyll + Minimal Mistakes로 만들었던 블로그를 Hugo로 이전했습니다.\n왜 Hugo인가? 가장 큰 이유는, Ruby보다는 Hugo가 사용하는 언어인 Go에 경험이 많았기 때문입니다. 사실 이 점이 블로그 글 작성에 큰 영향을 미치지는 않습니다. 실제 사용시에는 Hugo cli 명령어 정도만 사용하니까요. 하지만 혹시 모를 문제 발생시에 해결하기 훨씬 수월할 것 같다는 안정감이 들었습니다. Hugo를 사용한 정적 웹사이트 개발 프로젝트를 수행했던 경험이 있고, Hugo가 사용하는 템플릿 언어인 text/template 을 자주 사용했습니다. macOS에서 빌드 속도가 Jekyll에 비해 매우 빠릅니다. Linux에서는 비슷한 성능을 보여줬지만, macOS의 경우 Jekyll은 체감 빌드 시간이 1분 정도 걸리는 데 비해 Hugo는 대략 3초 이내로 빌드가 완료됩니다. Hot Reload를 지원해 테마 개발이 편리합니다. Google Analytics, 목차 생성 기능 등 기본 제공되는 기능들이 풍부합니다. 테마를 git submodule로 관리해 소스트리가 깔끔합니다. 단점은? Github pages에서 기본적으로 지원하지 않습니다. Jekyll의 경우, 별도 설정 없이 페이지 빌드와 배포가 자동으로 수행되는 반면, Hugo의 경우 Github Actions를 수동으로 설정해 주어야 합니다. 단점이 별로 없는 것 같지만, 위 단점이 생각보다 많이 컸습니다. 그래서 사실 Go를 많이 좋아하고, 경험이 있는 것이 아니라면 그냥 Jekyll을 사용하는 것이 나을지도 모르겠네요.\nHugo를 사용한 또 다른 이유에는 PaperMod 테마를 사용하기 위한 것도 있었습니다. 미니멀한 디자인이고, 퍼지 검색 기능을 기본적으로 지원한다는 점이 마음에 들었어요.\n이전 과정 1. Hugo 초기화 및 기존 블로그 정리 먼저, 기존 블로그 디렉토리에서 Hugo 사이트를 생성했습니다. 디렉토리가 비어 있지 않기 때문에 --force를 사용해 강제로 초기화합니다.\nhugo new site . --force 그런 다음, 기존 포스트 파일들을 content/posts 디렉토리로 이동하고, 파일명 앞에 붙어 있던 날짜를 제거해 주었습니다. Hugo가 permalink 생성에 파일명을 사용하기 때문인데, 개인적으로는 날짜를 붙일 수 있는 Jekyll 방식이 더 마음에 듭니다. 파일명 정렬이 쉬워지니까요. Hugo에서도 이 방식을 사용할 수 있는지 찾아보아야겠습니다. 혹시 아시는 분 있으시면 댓글에 알려주세요.\nfor file in *; do mv $file $(echo $file | cut -c12-) ; done 루트 디렉터리에 두었던 CNAME, favicon.ico 파일 등은 static 디렉토리로 이동합니다.\n2. 테마 및 Hugo 설정 themes 폴더 아래에 테마 리포지터리를 git submodule로 추가해 줍니다. 저는 PaperMod를 사용했습니다.\ngit submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 테마의 config.yml파일을 참고해 Hugo를 설정해 줍니다. 주요 수정 내용은 다음과 같습니다.\n# 읽기 시간 계산등에 한국어에 맞는 계산법 적용 hasCJKLanguage: true # fuse 검색을 위해 JSON 인덱스 생성 outputs: home: - HTML - RSS - JSON # SEO를 위해 Jekyll과 동일하게 permalink 생성 permalinks: posts: /:2006/:01/:02/:filename 3. Github Actions 설정 Hugo 문서를 참고해 .github/workflows/gh-pages.yml 파일을 작성했습니다. 주의할 점은 on 설정과 Deploy step의 if에 브랜치 이름이 main으로 하드코딩되어 있다는 점입니다. 제 블로그는 master브랜치를 사용하기 때문에, 문서에 있는 파일을 그대로 사용했을 때 제대로 빌드되지 않는 문제가 발생했습니다.\n빌드가 완료되면 결과물이 gh-pages 브랜치에 푸시됩니다. 이 브랜치를 github pages 배포에 사용하도록 프로젝트를 설정합니다. ","permalink":"https://blog.dfkdream.dev/2023/02/13/migrate-jekyll-blog-to-hugo/","summary":"Jekyll + Minimal Mistakes로 만들었던 블로그를 Hugo로 이전했습니다. 왜 Hugo인가? 가장 큰 이유는, Ruby보다는 Hugo가 사용하는 언어인 Go에 경","title":"Jekyll 블로그 Hugo로 이전한 후기"},{"content":"Github 등 Git 서버에서는 커미터가 자신임을 증명하기 위해 GPG 서명을 사용할 수 있습니다. 이때 사용되는 GPG 키는 보안을 위해 유효기간을 지정하는 것이 권장되는데, 유효기간이 지나면 해당 키로 커밋을 할 수 없는 등 문제가 발생합니다.\n이런 문제가 발생했을 때 GPG 키를 갱신하는 방법입니다.\n테스트 환경 macOS Monterey gpg (GnuPG) 2.3.4 저장된 키 목록 확인 gpg --list-keys \u0026lt;keybox 파일 경로\u0026gt; ---------------------------------- pub rsa4096 \u0026lt;생성일\u0026gt; [SC] [expires: \u0026lt;만료일\u0026gt;] \u0026lt;Key ID\u0026gt; uid [ultimate] \u0026lt;username\u0026gt; \u0026lt;\u0026lt;email\u0026gt; sub rsa4096 \u0026lt;생성일\u0026gt; [E] [expires: \u0026lt;만료일\u0026gt;] Key ID는 유효기간 연장을 위해 필요하니 잘 확인하시기 바랍니다.\n키 유효기간 연장 gpg --edit-key \u0026lt;Key ID\u0026gt; 아무것도 입력하지 않으면 Primary key를 수정하게 됩니다.\ngpg\u0026gt; expire Changing expiration time for the primary key. Please specify how long the key should be valid. 0 = key does not expire \u0026lt;n\u0026gt; = key expires in n days \u0026lt;n\u0026gt;w = key expires in n weeks \u0026lt;n\u0026gt;m = key expires in n months \u0026lt;n\u0026gt;y = key expires in n years Key is valid for? (0) n+단위를 입력해 만료일을 오늘 날짜로부터 n만큼 연장시킵니다.\nSubkey의 유효기간도 연장시켜 줍시다.\ngpg\u0026gt; key 1 gpg\u0026gt; expire 이후의 명령은 Primary key와 동일합니다.\n마지막으로 수정 내용을 저장합니다.\ngpg\u0026gt; save 공개키 내보내기 gpg --armor --export \u0026lt;Key ID\u0026gt; 지정된 키를 텍스트 형식으로 내보냅니다. 표준 출력으로 키 내용이 출력되니 리디렉션을 사용해 클립보드에 바로 복사할 수도 있습니다.\n이제 Git 서버 관리 페이지에서 기존 공개키를 삭제하고 내보낸 키를 다시 등록하면 됩니다.\n","permalink":"https://blog.dfkdream.dev/2022/03/30/renewing-expired-gpg-key/","summary":"Github 등 Git 서버에서는 커미터가 자신임을 증명하기 위해 GPG 서명을 사용할 수 있습니다. 이때 사용되는 GPG 키는 보안을 위해 유효기간을 지정하는 것이 권장되는데, 유효기간","title":"만료된 GPG 키 갱신하기 (유효기간 연장)"},{"content":"pyenv, pyenv-virtualenv 설치 방법과 자주 사용되는 명령어들을 모아 보았습니다.\n테스트 환경 macOS Monterey iTerm2 ZSH pyenv 설치 brew install pyenv echo \u0026#39;eval \u0026#34;$(pyenv init --path)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zprofile echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 특정 버전의 python 설치 pyenv install \u0026lt;python-version\u0026gt; ex)\npyenv install 3.8.12 pyenv-virtualenv 설치 brew install pyenv-virtualenv echo \u0026#39;eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc virtualenv 생성 pyenv virtualenv \u0026lt;python-version\u0026gt; \u0026lt;venv-name\u0026gt; ex)\npyenv virtualenv 3.8.12 venv virtualenv 적용 pyenv activate \u0026lt;venv-name\u0026gt; ex)\npyenv activate venv 특정 폴더에 virtualenv 자동 적용 pyenv local \u0026lt;venv-name\u0026gt; ex)\npyenv local venv 실행 시 현재 디렉토리에 .python-version 파일이 생성되고 pyenv가 이 파일을 자동으로 인식해 가상 환경을 적용해 줍니다.\nvirtualenv 삭제 pyenv uninstall \u0026lt;venv-name\u0026gt; ex)\npyenv uninstall venv ","permalink":"https://blog.dfkdream.dev/2022/03/08/installing-and-using-pyenv-macos/","summary":"pyenv, pyenv-virtualenv 설치 방법과 자주 사용되는 명령어들을 모아 보았습니다. 테스트 환경 macOS Monterey iTerm2 ZSH pyenv 설치 brew install pyenv echo \u0026#39;eval \u0026#34;$(pyenv init --path)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zprofile echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 특정 버전의 python 설치 pyenv install \u0026lt;python-version\u0026gt; ex) pyenv install 3.8.12","title":"macOS에 pyenv 설치, 사용하기"},{"content":"zsh-autosuggestions와 zsh-syntax-highlighting은 zsh 사용을 엄청 편리하게 해 주는 플러그인입니다. 그런데 macOS에서 이 플러그인들을 설치했더니 플러그인 간에 충돌이 발생해 자동완성된 명령어가 보이지 않거나 하이라이팅이 제대로 되지 않는 문제가 발생했습니다. 이 포스트에서는 이런 문제들을 해결해 보겠습니다.\n테스트 환경 macOS Big Sur iTerm2 Build 3.3.7 oh-my-zsh 플러그인 설치 먼저 더 많은 명령어 자동 완성 목록을 사용하기 위해 zsh-completions를 설치해 줍시다.\n% git clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions 다음으로 zsh-syntax-highlighting과 zsh-autosuggestions를 설치해 주겠습니다.\n% git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting % git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 설치가 모두 끝나면 ~/.zshrc 파일을 다음과 같이 수정해 플러그인을 활성화해 주겠습니다.\nplugins=( [Plugins...] zsh-syntax-highlighting zsh-completions zsh-autosuggestions ) ... autoload -U compinit \u0026amp;\u0026amp; compinit 가장 마지막 줄의 autoload...는 zsh-completions 활성화를 위한 부분입니다. 파일 가장 마지막 줄에 추가해 줍시다.\n설치가 모두 끝났습니다! 마지막으로 다음 명령어를 입력해 설정 파일을 로드해 주겠습니다.\nsource ~/.zshrc 이러면 이제 자동완성과 문법 하이라이팅이 이쁘게 되어야 하는디\u0026hellip;\nTroubles 이대로 설정하면 데모에서 본 것처럼 표시가 되지 않습니다. 제 경우에는\n자동완성된 부분이 입력한 부분과 구분이 되지 않음 자동완성된 부분 글자가 하나만 보이고 나머지는 보이지 않음 이런 문제가 발생했습니다.\nTroubleshooting 자동완성된 부분이 입력한 부분과 구분이 되지 않음 먼저 1번 문제부터 고쳐 보겠습니다. 이 문제는 zsh-syntax-highlighting이 macOS Big Sur에 기본으로 설치된 zsh 5.8 (x86_64-apple-darwin20.0)을 인식하지 못해 발생하는 문제입니다. brew를 사용해 zsh를 업데이트(설치)해 줍시다.\n% brew install zsh 이제 터미널을 새로 열면 zsh가 업데이트된 것을 확인할 수 있습니다.\n% zsh --version zsh 5.8 (x86_64-apple-darwin20.1.0) (실행 시점과 OS버전 / 아키텍쳐에 따라 다를 수 있습니다.)\n이 문제는 이제 해결!\n자동완성된 부분 글자가 하나만 보이고 나머지는 보이지 않음 그런데.. 기본 테마가 아닌 Solarized Dark 등의 컬러 스킴을 사용하시는 경우 자동완성된 부분 글자가 제대로 보이지 않는 문제가 발생합니다. 이건 zsh-autosuggestions가 기본 자동완성 하이라이팅 색상으로 사용하는 ANSI Bright Black 색상이 Background 색상과 동일하게 설정되어 있어 생기는 문제입니다.\niTerm2 설정 (cmd+,) \u0026gt; Profiles \u0026gt; Colors \u0026gt; ANSI Colors \u0026gt; Black \u0026gt; Bright 색상을 다른 색으로 변경해 줍시다. 저의 경우 #2a5965로 설정했습니다.\n이러면 이제 진짜로 설정 끝!\n참고문헌 / 출처 본격 macOS에 개발 환경 구축하기 - Subicura\u0026rsquo;s Blog autosuggestion not working for oh-my-zsh #416 - zsh-users/zsh-autosuggestion Conflict with zsh-autosuggestions under zsh 5.8 (and only that version) #756 - zsh-users/zsh-syntax-highlighting ","permalink":"https://blog.dfkdream.dev/2020/02/21/zsh-autosuggest-with-highlight/","summary":"zsh-autosuggestions와 zsh-syntax-highlighting은 zsh 사용을 엄청 편리하게 해 주는 플러그인입니다. 그런데 ma","title":"zsh-autosuggest와 zsh-syntax-highlighting 충돌 문제 해결"},{"content":"리플렉션 (reflect 패키지) 를 사용하면 구조체를 배열처럼 인덱스로 접근할 수 있습니다.\nimport( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strconv\u0026#34; ) type test struct{ A int B int C string } 값 읽기 t := test{1,2,\u0026#34;3\u0026#34;} fmt.Println(reflect.ValueOf(t).Field(0).Int()) fmt.Println(reflect.ValueOf(t).Field(1).Int()) fmt.Println(reflect.ValueOf(t).Field(2).String()) 결과 1 2 3 자료형이 일치하지 않을 경우 패닉이 발생합니다.\nt := test{1,2,\u0026#34;3\u0026#34;} fmt.Println(reflect.ValueOf(t).Field(0).Int()) fmt.Println(reflect.ValueOf(t).Field(1).Int()) fmt.Println(reflect.ValueOf(t).Field(2).Int()) 결과 1 2 panic: reflect: call of reflect.Value.Int on string Value 그러므로 값을 읽기 전에는 Kind() 함수를 이용해 타입 검사를 해 주어야 합니다.\nt := test{1,2,\u0026#34;3\u0026#34;} for i:=0;i\u0026lt;3;i++{ if reflect.ValueOf(t).Field(i).Kind()==reflect.String{ fmt.Println(reflect.ValueOf(t).Field(i).String()) }else{ fmt.Println(reflect.ValueOf(t).Field(i).Int()) } } 결과 1 2 3 값 쓰기 var t test reflect.ValueOf(\u0026amp;t).Elem().Field(0).SetInt(int64(1)) reflect.ValueOf(\u0026amp;t).Elem().Field(1).SetInt(int64(2)) reflect.ValueOf(\u0026amp;t).Elem().Field(2).SetString(\u0026#34;3\u0026#34;) fmt.Println(t) 결과 {1 2 3} 값을 읽는 코드와 비슷합니다. 다만 구조체 필드의 값을 변경하기 위해 ValueOf 함수의 파라미터로 포인터를 넘겼고 역참조를 위해 Elem() 함수를 사용하고 있습니다.\n값 쓰기의 경우에도 읽기와 마찬가지로 자료형이 일치하지 않을 경우 패닉이 발생합니다.\nvar t test reflect.ValueOf(\u0026amp;t).Elem().Field(0).SetInt(int64(1)) reflect.ValueOf(\u0026amp;t).Elem().Field(1).SetInt(int64(2)) reflect.ValueOf(\u0026amp;t).Elem().Field(2).SetInt(int64(3)) fmt.Println(t) 결과 panic: reflect: call of reflect.Value.SetInt on string Value 그러므로 Kind() 함수를 이용해 타입 검사를 해 주어야 합니다.\nvar t test a:=[]int{1,2,3} for i,n:=range a{ if reflect.ValueOf(t).Field(i).Kind()==reflect.String{ reflect.ValueOf(\u0026amp;t).Elem().Field(i).SetString(strconv.Itoa(n)) }else{ reflect.ValueOf(\u0026amp;t).Elem().Field(i).SetInt(int64(n)) } } fmt.Println(t) 결과 {1 2 3} 쓰기의 경우 읽기와는 다르게 구조체 필드가 내보내기(Export)되지 않았을 경우(=앞 글자가 대문자가 아닐 경우) 패닉이 발생하므로 주의해야 합니다.\n","permalink":"https://blog.dfkdream.dev/2019/04/05/struct-indexing-in-go/","summary":"리플렉션 (reflect 패키지) 를 사용하면 구조체를 배열처럼 인덱스로 접근할 수 있습니다. import( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strconv\u0026#34; ) type test struct{ A int B int C string } 값 읽기 t := test{1,2,\u0026#34;3\u0026#34;} fmt.Println(reflect.ValueOf(t).Field(0).Int()) fmt.Println(reflect.ValueOf(t).Field(1).Int()) fmt.Println(reflect.ValueOf(t).Field(2).String()) 결과 1 2 3 자료형이 일치","title":"[Golang] 구조체 필드를 배열처럼 접근하기"},{"content":"데이터와 행 이름을 리스트로 넣으면 표를 출력해 주는 함수입니다.\n한글을 포맷팅하면 전각 한글을 한 글자로 계산해 표가 제대로 출력되지 않는데, 해당 문제를 해결해 두었습니다. 다른 전각 문자를 사용하려면 reKo 부분에 해당 문자 구간을 추가하면 됩니다.\n제어 문자열 \u0026quot;SEP\u0026quot;를 데이터 리스트에 포함시키면 행 구분을 출력합니다.\nSource Code import re def drawTable(identifiers,datas): reKo=re.compile(\u0026#34;[가-힣]\u0026#34;) maxLength=[len(str(x))+len(reKo.findall(str(x))) for x in identifiers] for data in datas: for index,d in enumerate(data): if d==\u0026#34;SEP\u0026#34;: continue if maxLength[index]\u0026lt;len(str(d))+len(reKo.findall(str(d))): maxLength[index]=len(str(d))+len(reKo.findall(str(d))) divider=\u0026#34;-\u0026#34;*(sum(maxLength)+(len(maxLength)+1)+len(maxLength)*2) print(divider) formatString=\u0026#34;|\u0026#34;+\u0026#34;\u0026#34;.join([\u0026#34; {0}{1}:^{2}{3} |\u0026#34;.format(\u0026#34;{\u0026#34;,index,length-len(reKo.findall(str(identifiers[index]))),\u0026#34;}\u0026#34;) for index,length in enumerate(maxLength)]) print(formatString.format(*identifiers)) print(divider) for data in datas: if data==\u0026#34;SEP\u0026#34;: print(divider) continue formatString=\u0026#34;|\u0026#34;+\u0026#34;\u0026#34;.join(\u0026#34; {0}{1}:^{2}{3} |\u0026#34;.format(\u0026#34;{\u0026#34;,index,length-len(reKo.findall(str(data[index]))),\u0026#34;}\u0026#34;) for index,length in enumerate(maxLength)) print(formatString.format(*data)) print(divider) 실행 예시 drawTable([\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;합계\u0026#34;],[[1,2,3],[4,5,9],\u0026#34;SEP\u0026#34;,[5000,5000,10000]]) Output 주의: 고정폭 폰트를 사용해야 표가 제대로 표시됩니다.\n----------------------- | a | b | 합계 | ----------------------- | 1 | 2 | 3 | | 4 | 5 | 9 | ----------------------- | 5000 | 5000 | 10000 | ----------------------- ","permalink":"https://blog.dfkdream.dev/2018/09/19/draw-table-in-python/","summary":"데이터와 행 이름을 리스트로 넣으면 표를 출력해 주는 함수입니다. 한글을 포맷팅하면 전각 한글을 한 글자로 계산해 표가 제대로 출력되지 않는데, 해당 문제를 해결해 두","title":"Python3 CLI 스크립트에서 표 그리기"},{"content":"Golang으로 애플리케이션 개발을 하면서 HTML 파서를 사용할 일이 가끔 있었습니다. golang.org/x/net/html 파서는 Python의 BeautifulSoup처럼 사용하기 편하게 구성되어 있지 않아 사용법을 간단히 정리해 보았습니다.\nCodes 예제 코드의 실행 결과에는 아래 HTML 노드를 사용했습니다. 편의상 예제 코드에서는 생략하도록 하겠습니다.\n아래 코드는 HTML 문서 전체가 아닌 노드 일부입니다. 문서 전체가 아닌 일부만을 html.Parse 함수에 전달할 경우 파서가 누락된 노드들(\u0026lt;html\u0026gt;,\u0026lt;head\u0026gt;,\u0026lt;body\u0026gt;등)을 알아서 추가합니다.\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; HTML 노드 렌더링 (renderNode) Code 아래 예시 소스코드들에서 사용되는 함수입니다. stackoverflow를 참고했습니다.\nfunc renderNode(n *html.Node) string { var buf bytes.Buffer w := io.Writer(\u0026amp;buf) html.Render(w, n) return buf.String() } 결과 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 하위 노드 전체 렌더링하기 Code var result =\u0026#34;\u0026#34; for d := n.FirstChild; d != nil; d = d.NextSibling { result += renderNode(d) } 결과 \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; 자식 노드 전체 탐색 HTML 파싱에는 일반적으로 이 코드를 사용합니다. 자식 노드 전체를 재귀적으로 탐색합니다.\nCode var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode{ fmt.Println(n.Data) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 ul li li li a 특정 자식 노드의 Text 읽기 Code var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data==\u0026#34;li\u0026#34;{ fmt.Println(n.FirstChild.Data) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 Item 1 Item 2 a Item 1과 Item 2의 경우 해당 텍스트 노드가 \u0026lt;li\u0026gt; 태그의 첫 번째 자식 노드(FirstChild)이기 때문에 정상적으로 출력될 수 있었습니다. 그렇지만 Item 3의 경우 \u0026lt;li\u0026gt; 태그의 첫 번째 자식 노드가 텍스트 노드가 아닌 \u0026lt;a\u0026gt; 태그이기 때문에 Item 3가 아닌 a가 출력이 되었습니다. 이러한 경우를 방지하기 위해 n.FirstChild.Data 대신 renderNode 함수를 사용합니다.\nCode (renderNode 함수 사용) var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data==\u0026#34;li\u0026#34;{ fmt.Println(renderNode(n.FirstChild)) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 Item 1 Item 2 \u0026lt;a href=\u0026#34;http://www.example.com\u0026#34;\u0026gt;Item 3\u0026lt;/a\u0026gt; 다만, renderNode를 사용할 경우 파싱 결과에 HTML이 포함됩니다. 파싱 결과에 HTML이 포함되어도 되는 경우에만 사용할 수 있겠습니다.\nAttribute 값 읽기 Code var f func(*html.Node) f=func(n *html.Node){ if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data==\u0026#34;a\u0026#34;\u0026amp;\u0026amp; len(n.Attr)\u0026gt;0\u0026amp;\u0026amp;n.Attr[0].Key==\u0026#34;href\u0026#34;{ fmt.Println(n.Attr[0].Val) } for c:=n.FirstChild; c != nil; c = c.NextSibling{ f(c) } } f(node) 결과 http://www.example.com len(n.Attr)\u0026gt;0을 추가하지 않을 경우 Attribute가 없는 태그(예시의 경우 \u0026lt;a\u0026gt;)를 만났을 때 runtime error: index out of range Panic이 발생합니다.\nnet/html 파서를 사용하기 불편하다면 goquery 등의 다른 라이브러리를 사용하는 것도 좋겠습니다.\n변경 기록 2023-02-09\nrenderNode 함수의 위치를 문서 최상위로 변경했습니다. 의견 주신 @mingkyme 님 감사합니다. ","permalink":"https://blog.dfkdream.dev/2018/09/15/using-golang-net-html-parser/","summary":"Golang으로 애플리케이션 개발을 하면서 HTML 파서를 사용할 일이 가끔 있었습니다. golang.org/x/net/html 파서는 Python의 BeautifulSoup처럼 사용하기 편하게","title":"Golang HTML 파서 사용하기"},{"content":"#include \u0026lt;stdio.h\u0026gt; int main(){ int i=0; scanf(\u0026#34;%d\\n\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); return 0; } scanf는 문자가 매칭이 안 되고 다음 문자가 whitespace가 아닐 때 까지 읽고 문자열이 남을 경우 나머지를 버퍼에 남긴다.\nscanf에 \\n이 들어갈 경우 줄바꿈이 매칭되므로 scanf가 종료되지 않고 다음 readable character가 들어올 때 까지 대기한다.\n이 예시의 경우 format string에 conversion specification이 하나밖에 없으므로 첫 readable character을 i에 쓰고 버퍼에 다음 character를 남긴다. 그래서 다음 scanf() 호출 시에 아무것도 입력하지 않아도 그 전에 입력했던 문자열을 버퍼에서 읽어와 출력하게 된다.\n(K\u0026amp;K 2/E p.46 참고)\n결론: scanf 끝에 줄바꿈 문자를 넣지 말자\n특별한 상황에서는 쓸 수도 있겠지만\u0026hellip; :)\n","permalink":"https://blog.dfkdream.dev/2018/09/12/do-not-use-line-feed-in-scanf/","summary":"#include \u0026lt;stdio.h\u0026gt; int main(){ int i=0; scanf(\u0026#34;%d\\n\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); printf(\u0026#34;%d\\n\u0026#34;,i); return 0; } scanf는 문자가 매칭이 안 되고 다음 문자가 whitespace가 아닐 때 까지 읽고 문자열이 남을 경우 나머지를 버퍼에 남긴다.","title":"scanf()의 format string에 줄바꿈을 사용하면 안 되는 이유"},{"content":"뭐하지??\n","permalink":"https://blog.dfkdream.dev/2018/09/10/first-post/","summary":"뭐하지??","title":"Github pages 첫번째 포스트"}]